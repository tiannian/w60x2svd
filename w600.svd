<?xml version="1.0" encoding="UTF-8"?><device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"><name>w600</name><version>v0.1</version><description>w600</description><width>32</width><peripherals><peripheral><name>7816</name><version>0.1</version><description>7861/UART2</description><baseAddress>0x40011c00</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>uart_line_ctrl</name><addressOffset>0x0</addressOffset><description>uart&amp;7816 通信的数据相关设置</description><size>32</size><access>read-write</access><resetValue>0x0033520b</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>25</bitOffset><bitWidth>7</bitWidth></field><field><name>sc_mode</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>sc_mode</name><usage>read-write</usage><enumeratedValue><name>sc_mode_0</name><description>uart 模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>sc_mode_1</name><description>7816 模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rx_retrans_en</name><description>模式7816 T0</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rx_retrans_en</name><usage>read-write</usage><enumeratedValue><name>rx_retrans_en_0</name><description>Rx 自动重传无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rx_retrans_en_1</name><description>Rx 自动重传使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rx_retrans_cnt</name><description>模式7816 卡 T0</description><bitOffset>20</bitOffset><bitWidth>3</bitWidth><access>read-write</access></field><field><name>tx_retrans_en</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tx_retrans_en</name><usage>read-write</usage><enumeratedValue><name>tx_retrans_en_0</name><description>Tx 自动重传无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tx_retrans_en_1</name><description>Tx 自动重传使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tx_retrans_cnt</name><description>模式7816 卡T0tx 自动重传次数</description><bitOffset>16</bitOffset><bitWidth>3</bitWidth><access>read-write</access></field><field><name>min_block_guard_time</name><description>7816 卡的最小MIN_BGT（Min Block Guard Time  ）Min Block Guard Time 计算： 10+stop 位(默认 2 位)+配置值MIN_BGT Note:T=0：在发送和接收的两个相反方向连续字符的起始位下降沿之间的最小时间间隔不能小于 16 个 ETU。必须能够正确解释接收到的其起始位下降沿和最后发送的字节起始位下降沿间隔为 15 个 ETU 的字符。T=1：在发送和接收的两个相反方向连续字符的起始位下降沿之间的最小时间间隔（块保护时间，BGT）必须为 22 个 ETU。必须能够正确解释接收到的其起始位下降沿和最后发送的字节起始位下降沿间隔为 21 个 ETU 以内接收到的字符。</description><bitOffset>11</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>7816_tmr_cfg</name><description>7816 卡时钟控制配置</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>7816_tmr_cfg</name><usage>read-write</usage><enumeratedValue><name>7816_tmr_cfg_0</name><description>在配置为卡模式时产生卡时钟输出，否则卡时钟输出无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>7816_tmr_cfg_1</name><description>时钟停止</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>7816_parity_error</name><description>7816 卡的parity 错误时是否接收数据</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>7816_parity_error</name><usage>read-write</usage><enumeratedValue><name>7816_parity_error_0</name><description>不接收</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>7816_parity_error_1</name><description>接收</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>7816_mode</name><description>7816 卡的T0/T1 模式配置，</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>7816_mode</name><usage>read-write</usage><enumeratedValue><name>7816_mode_0</name><description>T0 模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>7816_mode_1</name><description>T1 模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>uart_rx_enable</name><description>uart/7816 模式下，接收使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>uart_tx_enable</name><description>uart/7816 模式下，发送使能，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>send_break_enable</name><description>发送break 数据包。Uart 会在该为被置位后发送完一个break 数据包，发送完成后自动清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>parity</name><usage>read-write</usage><enumeratedValue><name>parity_0</name><description>偶校验</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>parity_1</name><description>奇校验</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>parity_0</name><description>LSB（b0 bit）先传输</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>parity_1</name><description>MSB（b7 bit）先传输</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>parity_en</name><description>使能，高有效(UART 模式)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>stop_bit_count</name><description>个数（UART 模式）stop bit 个数（7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>stop_bit_count</name><usage>read-write</usage><enumeratedValue><name>stop_bit_count_0</name><description>1 个停止位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>stop_bit_count_1</name><description>2 个停止位</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>stop_bit_count_0</name><description>0.5 个停止位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>stop_bit_count_1</name><description>1.5 个停止位</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>uart_bit_length</name><description>比特长度（UART 模式）</description><bitOffset>0</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>uart_bit_length</name><usage>read-write</usage><enumeratedValue><name>uart_bit_length_0</name><description>5bit 2’h16bit 2’h27bit 2’h38bit</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>auto_flow_ctrl</name><addressOffset>0x4</addressOffset><description>uart rts/cts 硬件流控设置</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>5</bitOffset><bitWidth>27</bitWidth></field><field><name>rts_trigger_level</name><description>（UART 模式）在afc_enable 有效时，决定何时需要将RTS 置无效。</description><bitOffset>2</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>rts_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rts_trigger_level_0</name><description>rxfifo 有 4 个以上字节 3’h1rxfifo 有 8 个以上字节 3’h2rxfifo 有 12 个以上字节 3’h3rxfifo 有 16 个以上字节 3’h4rxfifo 有 20 个以上字节 3’h5rxfifo 有 24 个以上字节 3’h6rxfifo 有 28 个以上字节</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rts_trigger_level_7</name><description>rxfifo 有 31 个以上字节</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>rts_set</name><description>（UART 模式）当AFC_enable 无效时，软件可以通过设置此位来完成接收流量控制。当 AFC_enable有效时，此位不关心。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>afc_enable</name><description>（UART 模式）接收条件rts 使用rts_trigger_level 控制产生，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>dma_ctrl</name><addressOffset>0x8</addressOffset><description>uart&amp;7816 dma 传输模式设置</description><size>32</size><access>read-write</access><resetValue>0x00000024</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>rxfifo_timeout_num</name><description>（UART 模式）rxfifo 中存在数据小于rxfifo_trigger_level 情况下，如果 N 个包的时间内，没有接收到新的数据时，产生rxfifo timeout 中断。该计时功能使能后，无论是第一次计时还是上一次计时完成，都只在接收到至少 1个包后才开始计时</description><bitOffset>3</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>rxfifo_timeout_en</name><description>（UART&amp;7816 模式）rxfifo 超时使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rx_dma_enable</name><description>（UART&amp;7816 模式）接收DMA 使能，高有效。0 表示接收过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_dma_enable</name><description>（UART&amp;7816 模式）发送DMA 使能，高有效。0 表示发送过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>uart_fifo_ctrl</name><addressOffset>0xc</addressOffset><description>设置 uart&amp;7816 fifo 触发等级</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>6</bitOffset><bitWidth>26</bitWidth></field><field><name>rxfifo_trigger_level</name><description>(UART&amp;7816 模式)</description><bitOffset>4</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>rxfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rxfifo_trigger_level_0</name><description>1byte</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_1</name><description>4byte 2’h28byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_3</name><description>16byte</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>txfifo_trigger_level</name><description>(UART&amp;7816 模式)</description><bitOffset>2</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>txfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>txfifo_trigger_level_0</name><description>empty</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_1</name><description>4byte 2’h28byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_3</name><description>16byte</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>rxfifo_reset</name><description>(UART&amp;7816 模式)复位rxfifo， 将rxfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_reset</name><description>(UART&amp;7816 模式)复位txfifo，将txfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>baud_rate_ctrl</name><addressOffset>0x10</addressOffset><description>设置uart 波特率、7816 时钟</description><size>32</size><access>read-write</access><resetValue>0x00030082</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>20</bitOffset><bitWidth>12</bitWidth></field><field><name>ubdiv_frac</name><description>UART 模式：系统时钟除以 16 倍波特率时钟商的小数部分指示。具体值为frac×16 。（参考章节波特率计算方法）7816 模式：ubdiv_frac = (fclk_apb + fsc_clk)/(2 * fsc_clk) - 1;（参考 7816 时钟计算方法）</description><bitOffset>16</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>ubdiv</name><description>UART 模式：系统时钟除以 16 倍波特率时钟商的整数部分减 1。默认系统时钟为 40MHz，波特率为 19200。（参考波特率计算方法）7816 模式：ubdiv=Fi/Di (Fi、Di 为智能卡反馈的参数,edu 频率：f_etuclk = fsc_clk/(ubdiv+1))（参考章节 7816 速率计算方法）</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>int_mask</name><addressOffset>0x14</addressOffset><description>设置uart&amp;7816 需要使用的中断</description><size>32</size><access>read-write</access><resetValue>0x000003ff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>10</bitOffset><bitWidth>22</bitWidth></field><field><name>7816_error_signal</name><description>卡发送时收到error signal 错误信号。（7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>overrun_error_int_mask</name><description>， rxfifo 溢出中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error_int_mask</name><description>，奇偶检验中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error_int_mask</name><description>，数据帧出错中断屏蔽位，高有效。（UART 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect_int_mask</name><description>，break 信号检测中断屏蔽位，高有效。（UART 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed_indicate_mask</name><description>，CTS 信号变化中断屏蔽位，高有效。（UART 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout_int_mask</name><description>，rxfifo 接收数据超时中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_int_mask</name><description>，rxfifo 达到触发值中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_int_mask</name><description>，txfifo 达到触发值中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_empty_int_mask</name><description>，txfifo 为空中断屏蔽位，高有效。（UART&amp;7816 模式）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>int_src</name><addressOffset>0x18</addressOffset><description>uart&amp;7816 中断状态指示</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>7816_error_signal</name><description>卡发送时收到error signal 错误信号。(7816 模式)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>overrun_error</name><description>（UART&amp;7816 模式）rxfifo 出现溢出。 软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error</name><description>（UART&amp;7816 模式）接收到的包校验位错误。DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error</name><description>（UART 模式）接收到的包停止位错误。DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect</name><description>（UART 模式）接收到break 包。DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed</name><description>（UART 模式）cts 信号变化则产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout</name><description>（UART&amp;7816 模式）rxfifo 中数据长度小于rxfifo trigger level 但N 个数据周期没有接收到任何数据，则产生中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_interrupt</name><description>（UART&amp;7816 模式）当rxfifo 中数据个数由小于rxfifo trigger level 中指定的数变成大于或等于该数时，产生此中断。此时应该根据rxfifo count 确定当前数据帧大小。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_interrupt</name><description>（UART&amp;7816 模式）当txfifo 中数据个数由大于txfifo trigger level 中指定的数变成小于或等于该数时，产生中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_fifo_empty_interrupt</name><description>（UART&amp;7816 模式）当发送完成当前包，并且txfifo 为空时，产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>fifo_status</name><addressOffset>0x1c</addressOffset><description>fifo 状态，cts 状态查询</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>13</bitOffset><bitWidth>19</bitWidth></field><field><name>cts_status</name><description>（UART 模式）当前cts 的状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_count</name><description>（UART&amp;7816 模式）rxfifo 中数据个数</description><bitOffset>6</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field><field><name>txfifo_count</name><description>（UART&amp;7816 模式）txfifo 中数据个数</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field></fields></register><register><name>tx_data_window</name><addressOffset>0x20</addressOffset><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tx_data_window</name><description>（UART&amp;7816 模式）发送数据起始地址。注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>rx_data_window</name><addressOffset>0x30</addressOffset><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rx_data_window</name><description>（UART&amp;7816 模式）接收数据起始地址。注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register><register><name>guard_time</name><addressOffset>0x40</addressOffset><description>7816 数据间保护时间</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>ex_gt_num</name><description>7816 模式下，guard time 计算：10+stop 位+配置值ex_gt_num</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>wait_time</name><addressOffset>0x44</addressOffset><description>7816 接收数据超时时间</description><size>32</size><access>read-write</access><resetValue>0x00078000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>24</bitOffset><bitWidth>8</bitWidth></field><field><name>wait_time</name><description>计数器（以 ETU 为单位）7816 模式下：CWT 和BWT 时间，配置为最大默认值。（在 T1 模式下：BWT =（11 etu+ 2BWI*960*Fd/fsc））</description><bitOffset>0</bitOffset><bitWidth>24</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>crypto</name><version>0.1</version><description>GPSEC</description><baseAddress>0x40003200</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>src_addr</name><addressOffset>0x0</addressOffset><description>RC4/SHA1/AES/DES/3DES/CRC/MD5
复用源地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>dest_addr</name><addressOffset>0x4</addressOffset><description>RC4/AES/DES/3DES 复用目的地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>gpsec_cfg</name><addressOffset>0x8</addressOffset><description>通用硬件加密模块配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>rng_start</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rng_start</name><usage>read-write</usage><enumeratedValue><name>rng_start_0</name><description>不启动RNG</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rng_start_1</name><description>启动RNG</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rng_load_seed</name><description>硬件自动清 0</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rng_load_seed</name><usage>read-write</usage><enumeratedValue><name>rng_load_seed_0</name><description>随机数发生器会默认以零为种子，产生相应位数的随机数</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rng_load_seed_1</name><description>种子加载完成以后开始生成随机数</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rng_switch</name><description>控制生成随机数的位数，</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rng_switch</name><usage>read-write</usage><enumeratedValue><name>rng_switch_0</name><description>16 位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rng_switch_1</name><description>32 位</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>des_soft_reset</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>des_soft_reset</name><usage>read-write</usage><enumeratedValue><name>des_soft_reset_0</name><description>不产生软复位且不改变当前状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>des_soft_reset_1</name><description>加密算法被软件复位为初始状态</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>aes_soft_reset</name><description>aes 软复位完成后硬件自动清 0</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>aes_soft_reset</name><usage>read-write</usage><enumeratedValue><name>aes_soft_reset_0</name><description>不产生软复位且不改变当前状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>aes_soft_reset_1</name><description>加密算法被软件复位为初始状态</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rc4_soft_reset</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rc4_soft_reset</name><usage>read-write</usage><enumeratedValue><name>rc4_soft_reset_0</name><description>不产生软复位且不改变当前状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rc4_soft_reset_1</name><description>加密算法被软件复位为初始状态</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>crc_datarev</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>crc_datarev</name><usage>read-write</usage><enumeratedValue><name>crc_datarev_0</name><description>CRC 输入数据不反向</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>crc_datarev_1</name><description>CRC 输入数据反向</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>crc_chksrev</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>crc_chksrev</name><usage>read-write</usage><enumeratedValue><name>crc_chksrev_0</name><description>CRC 输出结果不反向</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>crc_chksrev_1</name><description>CRC 输出结果反向</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>sub_mode</name><description>算法类型子模式选择：</description><bitOffset>21</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>sub_mode</name><usage>read-write</usage><enumeratedValue><name>sub_mode_00</name><description>DES/AES 密码算法的ECB 模式，可复用 CRC 算法的 CRC8 模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>sub_mode_01</name><description>3DES/AES 密码算法的 CBC，可复用 CRC 算法的CRC16_0 模式</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>sub_mode_10</name><description>AES 密码算法的CTR 模式，可复用 CRC 算法的CRC16_1 模式</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>sub_mode_11</name><description>CRC 算法的CRC32</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>encrypt_decrypt</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>encrypt_decrypt</name><usage>read-write</usage><enumeratedValue><name>encrypt_decrypt_0</name><description>加密</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>encrypt_decrypt_1</name><description>解密</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>gpsec_int_mask</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>gpsec_int_mask</name><usage>read-write</usage><enumeratedValue><name>gpsec_int_mask_0</name><description>不屏蔽加/解密完成中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>gpsec_int_mask_1</name><description>屏蔽加/解密完成中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cypher_mode</name><description></description><bitOffset>16</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>cypher_mode</name><usage>read-write</usage><enumeratedValue><name>cypher_mode_000</name><description>RSV</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cypher_mode_001</name><description>RC4</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>cypher_mode_010</name><description>SHA1</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>cypher_mode_011</name><description>AES</description><value>0x00000003</value></enumeratedValue><enumeratedValue><name>cypher_mode_100</name><description>DES</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>cypher_mode_101</name><description>3DES</description><value>0x00000005</value></enumeratedValue><enumeratedValue><name>cypher_mode_110</name><description>CRC</description><value>0x00000006</value></enumeratedValue><enumeratedValue><name>cypher_mode_111</name><description>MD5</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>total_byte</name><description>总共需要加解密操作的byte 个数。</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpsec_ctrl</name><addressOffset>0xc</addressOffset><description>通用硬件加密模块控制寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>2</bitOffset><bitWidth>30</bitWidth></field><field><name>sec_stop</name><description>停止当前正在进行的加解密操作</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>sec_stop</name><usage>read-write</usage><enumeratedValue><name>sec_stop_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>sec_stop_1</name><description>加/解密停止</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>sec_strt</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>sec_strt</name><usage>read-write</usage><enumeratedValue><name>sec_strt_0</name><description>不启动加/解密</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>sec_strt_1</name><description>启动加/解密</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>key00</name><addressOffset>0x10</addressOffset><description>Key0 低 32 位第一个输入key
（RC4/AES/DES/3DES），复用 CRC Ci</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>key01</name><addressOffset>0x14</addressOffset><description>Key0 高 32 位第一个输入key
（RC4/AES/DES/3DES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>key10</name><addressOffset>0x18</addressOffset><description>Key1 低 32 位第二个输入key
（RC4/AES//3DES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>key11</name><addressOffset>0x1c</addressOffset><description>Key1 高 32 位第二个输入key
（RC4/AES//3DES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>key20</name><addressOffset>0x20</addressOffset><description>Key2 低 32 位第三个输入key（3DES），
复用iv1 低 32 位输入初始向量（AES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>key21</name><addressOffset>0x24</addressOffset><description>Key2 高 32 位第三个输入key（3DES），
复用iv1 高 32 位输入初始向量（AES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>iv00</name><addressOffset>0x28</addressOffset><description>IV0 低 32 位输入初始向量
（AES/DES/3DES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>iv01</name><addressOffset>0x2c</addressOffset><description>IV0 高 32 位输入初始向量
（AES/DES/3DES）</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register><register><name>gpsec_sts</name><addressOffset>0x30</addressOffset><description>通用硬件加密模块状态寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>17</bitOffset><bitWidth>15</bitWidth></field><field><name>int_flag</name><description>软件写 1 清零</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>int_flag</name><usage>read-write</usage><enumeratedValue><name>int_flag_0</name><description>不产生加/解密完成中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>int_flag_1</name><description>产生加/解密完成中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>transfer_cnt</name><description>当前加密完成的字节个数。
每次重新开启加解密时清 0，并重新开始计数。</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field></fields></register><register><name>sha1-digest0</name><addressOffset>0x34</addressOffset><description>sha1-digest0/MD5-digest0</description><size>32</size><access>read-write</access><resetValue>0x67452301</resetValue></register><register><name>sha1-digest1</name><addressOffset>0x38</addressOffset><description>sha1-digest1/MD5-digest1</description><size>32</size><access>read-write</access><resetValue>0xefcdab89</resetValue></register><register><name>sha1-digest2</name><addressOffset>0x3c</addressOffset><description>sha1-digest2/MD5-digest2</description><size>32</size><access>read-write</access><resetValue>0x98badcfe</resetValue></register><register><name>sha1-digest3</name><addressOffset>0x40</addressOffset><description>sha1-digest3/MD5-digest3</description><size>32</size><access>read-write</access><resetValue>0x10325476</resetValue></register><register><name>sha1-digest4</name><addressOffset>0x44</addressOffset><description>sha1-digest4/CRC</description><size>32</size><access>read-write</access><resetValue>0xc3d2e1f0</resetValue></register><register><name>rng_result</name><addressOffset>0x48</addressOffset><description>RNG 输出</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue></register></registers></peripheral><peripheral><name>dma</name><version>0.1</version><description>DMA</description><baseAddress>0x40000400</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>int_mask</name><addressOffset>0x0</addressOffset><description>设置需要屏蔽的DMA 中断</description><size>32</size><access>read-write</access><resetValue>0x0000ffff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>channel7_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel7_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel6_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel6_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel5_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel5_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel4_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel4_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel3_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel3_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel2_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel2_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel1_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel1_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel0_transfer_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel0_burst_done</name><description>中断屏蔽，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>int_src</name><addressOffset>0x4</addressOffset><description>指示当前DMA 的中断状态</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>channel7_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel7_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel6_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel6_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel5_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel5_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel4_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel4_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel3_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel3_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel2_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel2_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel1_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel1_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel0_transfer_done</name><description>中断状态，写 1 清 0。DMA 传输完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>channel0_burst_done</name><description>中断状态，写 1 清 0。DMA burst 完成产生中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>uart_ch</name><addressOffset>0x8</addressOffset><description>UART 外设时选择哪个UART</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>2</bitOffset><bitWidth>30</bitWidth></field><field><name>uart_dma_channel</name><description>选择：</description><bitOffset>0</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>uart_dma_channel</name><usage>read-write</usage><enumeratedValue><name>uart_dma_channel_0</name><description>: uart0  模块dma 通道 接入dma</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>uart_dma_channel_1</name><description>: uart1  模块dma 通道 接入dma</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>uart_dma_channel_2</name><description>: uart2/7816  模块dma 通道 接入dma</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>uart_dma_channel_3</name><description>:  保留</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>reserved</name><addressOffset>0xc</addressOffset><size>32</size></register><register><name>src_addr</name><addressOffset>0x10</addressOffset><description>DMA 传输的源地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>src_addr</name><description>非循环模式下，DMA 搬运的源地址，外设地址或内存地址</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>dest_addr</name><addressOffset>0x14</addressOffset><description>DMA 传输的目的地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>dest_addr</name><description>非循环模式下，DMA 搬运的目的地址，外设地址或内存地址</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>src_wrap_addr</name><addressOffset>0x18</addressOffset><description>循环模式下DMA 传输源地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>src_wrap_addr</name><description>循环模式下，DMA 搬运的源地址的起始地址，外设地址或内存地址</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>dest_wrap_addr</name><addressOffset>0x1c</addressOffset><description>循环模式下DMA 传输目的地址</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>dest_wrap_addr</name><description>循环模式下，DMA 搬运的目的地址的起始地址，外设地址或内存地址</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>wrap_size</name><addressOffset>0x20</addressOffset><description>循环模式下DMA 循环边界</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>dest_size</name><description>循环模式下，DMA 目的地址循环长度。
DMA 从起始地址依次递增搬运数据，当搬运数据字节数达到此设定值之后，会跳转到循环起始地址，从起始地址开始继续搬运数据</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>src_size</name><description>循环模式下，DMA 源地址循环长度。</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>chnl_ctrl</name><addressOffset>0x24</addressOffset><description>当前通道DMA 启动和停止</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>2</bitOffset><bitWidth>30</bitWidth></field><field><name>dma_stop</name><description>停止dma 操作，高有效。
DMA 会在完成当前burst 操作后停止，并同时清除chnl_on。软件应根据chnl_on
为 0 确定dma 已经完全停止。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>chnl_on</name><description>启动当前通道DMA 转换，高有效。
Dma 完成后转换或设置停止后，自动清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>dma_mode</name><addressOffset>0x28</addressOffset><description>设置DMA 的工作方式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>7</bitOffset><bitWidth>25</bitWidth></field><field><name>chain_link_en</name><description>链表方式下有效，表示 dma 在处理完第一个链表后，是否继续读取和处理后续链表。如果为 1，则更新链表中的next_desc_addr，并继续读取下一个链表，直到链表中 vld 为 0；如果为 0，则处理完成当前链表后即停止。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>dma_sel</name><description>外设传输时，选择当前DMA 通道的外设类型。
16 个dma_req 的选择。</description><bitOffset>2</bitOffset><bitWidth>4</bitWidth><access>read-write</access><enumeratedValues><name>dma_sel</name><usage>read-write</usage><enumeratedValue><name>dma_sel_0</name><description>uart rx dma req</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dma_sel_1</name><description>uart tx dma req</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>dma_sel_2</name><description>pwm_cap0_req</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>dma_sel_3</name><description>pwm_cap1_req</description><value>0x00000003</value></enumeratedValue><enumeratedValue><name>dma_sel_4</name><description>LS_SPI rx dma req</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>dma_sel_5</name><description>LS_SPI tx dma req</description><value>0x00000005</value></enumeratedValue><enumeratedValue><name>dma_sel_6</name><description>SD_ADC chnl0 req</description><value>0x00000006</value></enumeratedValue><enumeratedValue><name>dma_sel_7</name><description>SD_ADC chnl1 req</description><value>0x00000007</value></enumeratedValue><enumeratedValue><name>dma_sel_8</name><description>SD_ADC chnl2 req</description><value>0x00000008</value></enumeratedValue><enumeratedValue><name>dma_sel_9</name><description>SD_ADC chnl3 req</description><value>0x00000009</value></enumeratedValue><enumeratedValue><name>dma_sel_a</name><description>SD_ADC chnl4 req</description><value>0x0000000a</value></enumeratedValue><enumeratedValue><name>dma_sel_b</name><description>SD_ADC chnl5 req</description><value>0x0000000b</value></enumeratedValue><enumeratedValue><name>dma_sel_c</name><description>SD_ADC chnl6 req</description><value>0x0000000c</value></enumeratedValue><enumeratedValue><name>dma_sel_d</name><description>SD_ADC chnl7 req</description><value>0x0000000d</value></enumeratedValue><enumeratedValue><name>dma_sel_e</name><description>: I2S RX req</description><value>0x0000000e</value></enumeratedValue><enumeratedValue><name>dma_sel_f</name><description>: I2S TX req</description><value>0x0000000f</value></enumeratedValue></enumeratedValues></field><field><name>chain_mode</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>chain_mode</name><usage>read-write</usage><enumeratedValue><name>chain_mode_0</name><description>使用普通模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>chain_mode_1</name><description>使用链表模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>dma_mode</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>dma_mode</name><usage>read-write</usage><enumeratedValue><name>dma_mode_0</name><description>软件方式。</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dma_mode_1</name><description>硬件方式。</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>dma_ctrl</name><addressOffset>0x2c</addressOffset><description>设置DMA 传输数据流</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>24</bitOffset><bitWidth>8</bitWidth></field><field><name>total_byte</name><description>总共需要操作的byte 个数。需要与data_size 配置相一致，即若果为字操作，则应该为配置为 4 的整数倍；如果为半字操作，则应该配置为 2 的整数倍。</description><bitOffset>8</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>burst_size</name><description>设置DMA 每次搬运多少个单位的数据
当最后一次burst 大小超过剩余传输的个数时，使用burst 大小为剩余数据的大小。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>burst_size</name><usage>read-write</usage><enumeratedValue><name>burst_size_0</name><description>burst 为 1</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>burst_size_1</name><description>burst 为 4</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>data_size</name><description>设置DMA 的搬运单位</description><bitOffset>5</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>data_size</name><usage>read-write</usage><enumeratedValue><name>data_size_0</name><description>byte</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>data_size_1</name><description>half_word</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>data_size_2</name><description>word</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>data_size_3</name><description>保留</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>dest_addr_inc</name><description></description><bitOffset>3</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>dest_addr_inc</name><usage>read-write</usage><enumeratedValue><name>dest_addr_inc_0</name><description>每次操作后目的地址不变；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dest_addr_inc_1</name><description>每次操作后目的地址自动累加。</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>dest_addr_inc_2</name><description>保留</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>dest_addr_inc_3</name><description>循环操作，每次操作后目的地址自动累加,到达定义的循环边界跳转到循环起始地址。</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>src_addr_inc</name><description></description><bitOffset>1</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>src_addr_inc</name><usage>read-write</usage><enumeratedValue><name>src_addr_inc_0</name><description>每次操作后源地址不变；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>src_addr_inc_1</name><description>每次操作后源地址自动累加。</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>src_addr_inc_2</name><description>保留</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>src_addr_inc_3</name><description>循环操作，每次操作后源地址自动累加,到达定义的循环边界跳转到循环起始地址。</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>auto_reload</name><description>当完成当前DMA 搬运后，自动按当前DMA 配置重新下一次DMA 搬运。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>dma_status</name><addressOffset>0x30</addressOffset><description>获取当前已传输的字节数</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>transfer_cnt</name><description>当前传输的字节个数。
每次重新开启dma（chnl_on 置 1）清 0，并重新开始计数。</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>desc_addr</name><addressOffset>0x34</addressOffset><description>DMA 链表地址入口地址设置</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>desc_addr</name><description>链表使能时，作为链表的入口地址。每传输完成一次链表后，将下一个链表的基地址更新至此寄存器。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>cur_dest_addr</name><addressOffset>0x38</addressOffset><description>当前DMA 操作的地址</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>current_dest_addr</name><description>当前DMA 操作目的地址。
当软件停止dma 时，可以通过查看此寄存器获悉dma 将要操作的目的地址。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>gpioa</name><version>0.1</version><description>GPIOA</description><baseAddress>0x40010c00</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>gpio_data</name><addressOffset>0x0</addressOffset><description>读写GPIO 当前数据</description><size>32</size><access>read-write</access><resetValue>0x0000180b</resetValue><fields><field><name>gpio</name><description>当前数据，每BIT 与相应的GPIO 线对应</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_data_en</name><addressOffset>0x4</addressOffset><description>配置GPIO_DATA 的使能位</description><size>32</size><access>read-write</access><resetValue>0x0000ffff</resetValue><fields><field><name></name><description>对应GPIO_DATA 的BIT 使能位，只有对应 BIT 为 1 时，对 GPIO_DATA 相应位的操作才有效，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO_DATA[x]不可读写[x] = 1, GPIO_DATA[x]可读写</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_dir</name><addressOffset>0x8</addressOffset><description>配置GPIO 方向</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>方向控制，每BIT 与相应的GPIO 线对应，</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_pull_en</name><addressOffset>0xc</addressOffset><description>配置GPIO 上下拉</description><size>32</size><access>read-write</access><resetValue>0x0000ffff</resetValue><fields><field><name>gpio</name><description>上下拉控制，每BIT 与相应的GPIO 线对应，该寄存器为低有效，一个GPIO 只有一种上下拉状态，IO 属性参见 IO 复用表</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_af_sel</name><addressOffset>0x10</addressOffset><description>配置GPIO 复用功能使能位</description><size>32</size><access>read-write</access><resetValue>0x0000ffff</resetValue><fields><field><name>gpio</name><description>复用功能使能位，每BIT 对应相应GPIO 复用功能是否打开，1’bx：[x] = 0, GPIO[x]复用功能关闭[x] = 1, GPIO[x]复用功能打开[x] = 1 时，复用功能取决于GPIO_AF_S1 和GPIO_AF_S0 两个寄存器相应BIT的状态。S1.[x] = 0， S0.[x] = 0，复用功能 1(opt1) S1.[x] = 0， S0.[x] = 1，复用功能 2(opt2) S1.[x] = 1， S0.[x] = 0，复用功能 3(opt3) S1.[x] = 1， S0.[x] = 1，复用功能 4(opt4)[x] = 0 时，如果GPIO_DIR[x] = 0，且 GPIO_PULL_EN[x] = 1，则 GPIO 复用为opt6  模拟 IO 功能IO 复用功能参见芯片引脚复用关系</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_sf_s1</name><addressOffset>0x14</addressOffset><description>GPIO 复用功能选择位高地址位</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>复用功能选择位高地址位，和GPIO_AF_S0 共同决定复用功能IO 复用功能参见芯片引脚复用关系</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_af_s0</name><addressOffset>0x18</addressOffset><description>GPIO 复用功能选择位低地址位</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>复用功能选择位低地址位，和GPIO_AF_S1 共同决定复用功能如何配置参见GPIO_AF_SEL 寄存器说明</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_is</name><addressOffset>0x20</addressOffset><description>配置GPIO 的中断触发方式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>的中断触发方式，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断为边沿触发[x] = 1, GPIO[x]中断为电平触发</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ibe</name><addressOffset>0x24</addressOffset><description>配置GPIO 中断边沿触发模式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断边沿触发模式，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]边沿触发中断模式由GPIO_IEV 决定[x] = 1, GPIO[x]双沿都触发中断</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_iev</name><addressOffset>0x28</addressOffset><description>配置 GPIO  中断上下边沿触发或高低电平触发</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断上下边沿触发或高低电平触发选择，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断为低电平或下降沿触发[x] = 1, GPIO[x]中断为高电平或上升沿触发</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ie</name><addressOffset>0x2c</addressOffset><description>配置GPIO 中断使能</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断使能控制，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断失能[x] = 1, GPIO[x]中断使能</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ris</name><addressOffset>0x30</addressOffset><description>查询GPIO 裸中断状态（MASK 前）</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>裸中断状态（MASK 前），每 BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]没有中断产生[x] = 1, GPIO[x]有中断产生</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_mis</name><addressOffset>0x34</addressOffset><description>查询 GPIO  屏蔽后中断状态（MASK后）</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>屏蔽后中断状态（MASK 后），每 BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]没有中断产生（MASK 后）[x] = 1, GPIO[x]中断产生（MASK 后）</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ic</name><addressOffset>0x38</addressOffset><description>控制GPIO 中断清除</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断清除控制，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0,  无动作[x] = 1,  清除GPIO[x]中断状态</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>gpiob</name><version>0.1</version><description>GPIOA</description><baseAddress>0x40011200</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>gpio_data</name><addressOffset>0x0</addressOffset><description>读写GPIO 当前数据</description><size>32</size><access>read-write</access><resetValue>0x00007304</resetValue><fields><field><name>gpio</name><description>当前数据，每BIT 与相应的GPIO 线对应</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_data_en</name><addressOffset>0x4</addressOffset><description>配置GPIO_DATA 的使能位</description><size>32</size><access>read-write</access><resetValue>0x7fffffff</resetValue><fields><field><name></name><description>对应GPIO_DATA 的BIT 使能位，只有对应 BIT 为 1 时，对 GPIO_DATA 相应位的操作才有效，每BIT 与相应的GPIO 线对应</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_dir</name><addressOffset>0x8</addressOffset><description>配置GPIO 方向</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>方向控制，每BIT 与相应的GPIO 线对应，1’bx：</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_pull_en</name><addressOffset>0xc</addressOffset><description>配置GPIO 上下拉</description><size>32</size><access>read-write</access><resetValue>0xffffffff</resetValue><fields><field><name>gpio</name><description>上下拉控制，每BIT 与相应的GPIO 线对应，该寄存器为低有效，一个GPIO 只有一种上下拉状态，IO 属性参见 IO 复用表</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_af_sel</name><addressOffset>0x10</addressOffset><description>配置GPIO 复用功能使能位</description><size>32</size><access>read-write</access><resetValue>0xffffffff</resetValue><fields><field><name>gpio</name><description>复用功能使能位，每BIT 对应相应GPIO 复用功能是否打开，1’bx：[x] = 0, GPIO[x]复用功能关闭[x] = 1, GPIO[x]复用功能打开[x] = 1 时，复用功能取决于GPIO_AF_S1 和GPIO_AF_S0 两个寄存器相应BIT的状态。S1.[x] = 0， S0.[x] = 0，复用功能 1(opt1) S1.[x] = 0， S0.[x] = 1，复用功能 2(opt2) S1.[x] = 1， S0.[x] = 0，复用功能 3(opt3) S1.[x] = 1， S0.[x] = 1，复用功能 4(opt4)IO 复用功能参见芯片引脚复用关系[x] = 0 时，如果GPIO_DIR[x] = 0，且 GPIO_PULL_EN[x] = 1，则 GPIO 复用为opt6  模拟 IO 功能</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_sf_s1</name><addressOffset>0x14</addressOffset><description>GPIO 复用功能选择位高地址位</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>复用功能选择位高地址位，和GPIO_AF_S0 共同决定复用功能IO 复用功能参见芯片引脚复用关系</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_af_s0</name><addressOffset>0x18</addressOffset><description>GPIO 复用功能选择位低地址位</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>复用功能选择位低地址位，和GPIO_AF_S1 共同决定复用功能如何配置参见GPIO_AF_SEL 寄存器说明</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_is</name><addressOffset>0x20</addressOffset><description>配置GPIO 的中断触发方式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>的中断触发方式，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断为边沿触发[x] = 1, GPIO[x]中断为电平触发</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ibe</name><addressOffset>0x24</addressOffset><description>配置GPIO 中断边沿触发模式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断边沿触发模式，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]边沿触发中断模式由GPIO_IEV 决定[x] = 1, GPIO[x]双沿都触发中断</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_iev</name><addressOffset>0x28</addressOffset><description>配置GPIO 中断上下边沿触发或
高低电平触发</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断上下边沿触发或高低电平触发选择，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断为低电平或下降沿触发[x] = 1, GPIO[x]中断为高电平或上升沿触发</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ie</name><addressOffset>0x2c</addressOffset><description>配置GPIO 中断使能</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断使能控制，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]中断失能[x] = 1, GPIO[x]中断使能</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ris</name><addressOffset>0x30</addressOffset><description>查询 GPIO 裸中断状态（MASK前）</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>裸中断状态（MASK 前），每 BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]没有中断产生[x] = 1, GPIO[x]有中断产生</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_mis</name><addressOffset>0x34</addressOffset><description>查询 GPIO   屏蔽后中断状态（MASK 后）</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>屏蔽后中断状态（MASK 后），每 BIT 与相应的GPIO 线对应，1’bx：[x] = 0, GPIO[x]没有中断产生（MASK 后）[x] = 1, GPIO[x]中断产生（MASK 后）</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>gpio_ic</name><addressOffset>0x38</addressOffset><description>控制GPIO 中断清除</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>gpio</name><description>中断清除控制，每BIT 与相应的GPIO 线对应，1’bx：[x] = 0,  无动作[x] = 1,  清除GPIO[x]中断状态</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>i2c</name><version>0.1</version><description>I2C</description><baseAddress>0x40010000</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>prerlo</name><addressOffset>0x0</addressOffset><description>存放低 8 位的分频值，用以对 APB总线时钟进行分频</description><size>32</size><access>read-write</access><resetValue>0x000000ff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>prescale_lo</name><description>时钟分频配置prescale 的低 8bit。例如：apb_clk=40MHz, SCL=100KHzprescale = (40*1000)/(5*100) – 1 = 16’d79 apb_clk = 40M, SCL=400Kprescale=(40*1000)/(5*400) – 1 = 16’d19</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>prerhi</name><addressOffset>0x4</addressOffset><description>存放高 8 位的分频值，用以对 APB总线时钟进行分频</description><size>32</size><access>read-write</access><resetValue>0x000000ff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>prescale_hi</name><description>时钟分频配置prescale 的高 8bit。例如：apb_clk=40MHz, SCL=100KHzprescale = (40*1000)/(5*100) – 1 = 16’d79 apb_clk = 40M, SCL=400Kprescale=(40*1000)/(5*400) – 1 = 16’d19</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>ctr</name><addressOffset>0x8</addressOffset><description>用以控制中断的使能以及I2S 控制器的使能</description><size>32</size><access>read-write</access><resetValue>0x00000040</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>i2c_en</name><description>使能控制，</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>i2c_en</name><usage>read-write</usage><enumeratedValue><name>i2c_en_0</name><description>不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>i2c_en_1</name><description>使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>int_mask</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>int_mask</name><usage>read-write</usage><enumeratedValue><name>int_mask_0</name><description>允许中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>int_mask_1</name><description>不允许中断产生</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth></field></fields></register><register><name>txr_rxr</name><addressOffset>0xc</addressOffset><description>用以存放待发送的数据或者接收到的数据</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>rx_tx_byte</name><description>写该寄存器时，为发送寄存器TXR，表示下一个要发送的字节，当为设备地址时，[0]：1 时表示读，0 时表示写。读该寄存器时，为接收寄存器RXR，为最新从I2C 上接收到的字节。</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth></field></fields></register><register><name>cr_sr</name><addressOffset>0x10</addressOffset><description>用以控制一些数据读写相关的操作</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>sta</name><description>，控制产生START 时序</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>sta</name><usage>read-write</usage><enumeratedValue><name>sta_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>sta_1</name><description>产生START 时序</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>sto</name><description>，控制产生STOP 时序；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>sto</name><usage>read-write</usage><enumeratedValue><name>sto_0</name><description>无效</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>rd</name><description>，从 SLAVE 读；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rd</name><usage>read-write</usage><enumeratedValue><name>rd_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rd_1</name><description>从SLAVE 读</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>wr</name><description>，向 SLAVE 写；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>wr</name><usage>read-write</usage><enumeratedValue><name>wr_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>wr_1</name><description>向SLAVE 写</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>ack_nack</name><description>控制向SLAVE 送回 ACK/NACK；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>ack_nack</name><usage>read-write</usage><enumeratedValue><name>ack_nack_0</name><description>回ACK</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>ack_nack_1</name><description>回NAK</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>1</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>iack</name><description>，清除中断状态，1 有效；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>iack</name><usage>read-write</usage><enumeratedValue><name>iack_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>iack_1</name><description>清除中断标志</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxack</name><description>，从SLAVE 收到的ACK/NACK 状态；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>rxack</name><usage>read</usage><enumeratedValue><name>rxack_0</name><description>从SLAVE 收到 ACK</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxack_1</name><description>从SLAVE 收到NAK</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>busy</name><description>；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>busy</name><usage>read</usage><enumeratedValue><name>busy_0</name><description>STO 后置 0</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>busy_1</name><description>STA 后置 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>2</bitOffset><bitWidth>4</bitWidth><access>read-only</access></field><field><name>tip</name><description>；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>tip</name><usage>read</usage><enumeratedValue><name>tip_0</name><description>无传输正在进行</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tip_1</name><description>有传输正在进行</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>if</name><description>，中断状态位；</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>if</name><usage>read</usage><enumeratedValue><name>if_0</name><description>无中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>if_1</name><description>传输完成</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>txr</name><addressOffset>0x14</addressOffset><description>读取I2C 发送时的TXR 寄存器值</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>txr_read</name><description>只读，TXR 寄存器的读出值，功能描述见TXR_RXR 寄存器；</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-only</access></field></fields></register><register><name>cr</name><addressOffset>0x18</addressOffset><description>读取I2C 控制寄存器的设定值 CR</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>read_cr</name><description>只读，CR 寄存器的读出值，功能描述见CR_SR 寄存器；</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>i2s</name><version>0.1</version><description>I2S</description><baseAddress>0x40011a00</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>i2s control</name><addressOffset>0x0</addressOffset><description>控制I2S 相关功能，详见下述章节；</description><size>32</size><resetValue>0x00004800</resetValue><fields><field><name>rsv</name><description></description><bitOffset>27</bitOffset><bitWidth>5</bitWidth><access>read-only</access></field><field><name>timeout_ctrl</name><description>超时计数控制位，当此位被置 1 并且传输进程被主设备强制停止时，将不发生接收完成(RXDONE)中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>format</name><description>数据格式选择</description><bitOffset>24</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>format</name><usage>read-write</usage><enumeratedValue><name>format_00</name><description>I2S  数据格式 2’b01MSB Justified  数据格式 2’b10PCM A 声音数据格式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>format_11</name><description>PCM B 声音数据格式</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>rxlch</name><description>声道接收使能控制位注意：只有选择MONO_STEREO 的单声道模式时，此位才有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxlch</name><usage>read-write</usage><enumeratedValue><name>rxlch_0</name><description>使能接收右声道数据</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxlch_1</name><description>使能接收左声道数据</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>mono_stereo</name><description>单声道立体声选择位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>mono_stereo</name><usage>read-write</usage><enumeratedValue><name>mono_stereo_0</name><description>数据以立体声格式传输</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>mono_stereo_1</name><description>数据以单声道格式传输</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxdmaen</name><description>接收DMA 请求使能位注意：当使能传输DMA 请求并且RXFIFO 中的字的个数等于或者大于RXTH时，I2S 控制器会向DMA 发出传输请求直至RXFIFO 为空才停止DMA 传输。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxdmaen</name><usage>read-write</usage><enumeratedValue><name>rxdmaen_0</name><description>不使能发送DMA 请求</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxdmaen_1</name><description>使能发送DMA 请求</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txdmaen</name><description>发送DMA 请求使能位注意：当使能传输 DMA 请求并且 TXFIFO 中的字的个数小于TXTH 时，I2S 控制器会向DMA 发出传输请求直至TXFIFO 满才停止DMA 传输。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txdmaen</name><usage>read-write</usage><enumeratedValue><name>txdmaen_0</name><description>不使能发送DMA 请求</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txdmaen_1</name><description>使能发送DMA 请求</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxclr</name><description>清空RXFIFO注意：写 1 清空RXFIFO，由硬件自动清空。读此位永远返回 0</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxclr</name><usage>read-write</usage><enumeratedValue><name>rxclr_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxclr_1</name><description>清空RXFIFO</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txclr</name><description>清空TXFIFO注意：写 1 清空TXFIFO，由硬件自动清空。读此位永远返回 0</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txclr</name><usage>read-write</usage><enumeratedValue><name>txclr_0</name><description>无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txclr_1</name><description>清空TXFIFO</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>lzcen</name><description>左声道零交叉检测使能控制位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>lzcen</name><usage>read-write</usage><enumeratedValue><name>lzcen_0</name><description>停止左声道零交叉检测</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>lzcen_1</name><description>使能左声道零交叉检测</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rzcen</name><description>右声道零交叉检测使能控制位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rzcen</name><usage>read-write</usage><enumeratedValue><name>rzcen_0</name><description>停止右声道零交叉检测</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rzcen_1</name><description>使能右声道零交叉检测</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rsv</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxth</name><description>RXFIFO 阙值…注意：当RXFIFO 中现有的字等于或者多于RXTH 的值时，RXTHIF 位会被置位。此时可以根据设置来选择触发RXDMA 或者 I2S 中断</description><bitOffset>12</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>rxth</name><usage>read-write</usage><enumeratedValue><name>rxth_000</name><description>设置阙值为 0 个字</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxth_000</name><description>设置阙值为 1 个字</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxth_111</name><description>设置阙值为 7 个字</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>txth</name><description>TXFIFO 阙值…注意：当TXFIFO 中现有的字等于或者少于TXTH 的值时，TXTHIF 位会被置位。此时可以根据设置来选择触发TXDMA 或者I2S 中断</description><bitOffset>9</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>txth</name><usage>read-write</usage><enumeratedValue><name>txth_000</name><description>设置阙值为 0 个字</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txth_000</name><description>设置阙值为 1 个字</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txth_111</name><description>设置阙值为 7 个字</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>clk_phase_sel</name><description>选择时钟相位模式以上面提及的I2S 总线时序展示以上面提及的I2S 总线时序的反转形式展示</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>clk_phase_sel</name><usage>read-write</usage><enumeratedValue><name>clk_phase_sel_0</name><description>默认模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>clk_phase_sel_1</name><description>反转模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rsv</name><description></description><bitOffset>6</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>wdwidth</name><description>传输字长设置位</description><bitOffset>4</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>wdwidth</name><usage>read-write</usage><enumeratedValue><name>wdwidth_00</name><description>字长 8 bit</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>wdwidth_01</name><description>字长 16 bit</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>wdwidth_10</name><description>字长 24 bit</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>wdwidth_11</name><description>字长 32 bit</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>mute</name><description>传输哑声使能标志位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>mute</name><usage>read-write</usage><enumeratedValue><name>mute_0</name><description>从移位寄存器传输数据，正常操作模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>mute_1</name><description>将传输数据置 0，使声音静音</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxen</name><description>接收使能标志位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxen</name><usage>read-write</usage><enumeratedValue><name>rxen_0</name><description>停止I2S 数据接收</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxen_1</name><description>使能I2S 数据接收</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txen</name><description>传输使能标志位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txen</name><usage>read-write</usage><enumeratedValue><name>txen_0</name><description>停止I2S 数据传输</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txen_1</name><description>使能I2S 数据传输</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>i2sen</name><description>I2S 使能标志位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>i2sen</name><usage>read-write</usage><enumeratedValue><name>i2sen_0</name><description>不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>i2sen_1</name><description>使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>i2s_imask</name><addressOffset>0x4</addressOffset><description>控制开启或关闭I2S 中所有的中断</description><size>32</size><access>read-write</access><resetValue>0x000003ff</resetValue><fields><field><name>rsv</name><description></description><bitOffset>10</bitOffset><bitWidth>22</bitWidth><access>read-only</access></field><field><name>lzcimask</name><description>左声道零交叉中断使能标志位当使能中断，并且检测到左声道上有零交叉时，产生中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>lzcimask</name><usage>read-write</usage><enumeratedValue><name>lzcimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>lzcimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rzcimask</name><description>右声道零交叉中断使能标志位当使能中断，并且检测到右声道上有零交叉时，产生中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rzcimask</name><usage>read-write</usage><enumeratedValue><name>rzcimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rzcimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txdonemask</name><description>发送完成中断使能位当使能中断，并且TXFIFO 为空时，产生中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txdonemask</name><usage>read-write</usage><enumeratedValue><name>txdonemask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txdonemask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txthimask</name><description>TXFIFO 阙值中断使能位当使能中断，并且TXFIFO 中的数据数等于或者小于TXTH 时，产生中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txthimask</name><usage>read-write</usage><enumeratedValue><name>txthimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txthimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txovimask</name><description>TXFIFO 溢出中断使能位注意：当使能中断，TXFIFO 满，CPU 再向TXFIFO 中写数据时，TXOVIF 标志位将会被置位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txovimask</name><usage>read-write</usage><enumeratedValue><name>txovimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txovimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txudimask</name><description>TXFIFO 下溢中断使能位注意：当使能TXFIFO 下溢中断，并且检测到TXUDIF 为 1 时，将产生下溢中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txudimask</name><usage>read-write</usage><enumeratedValue><name>txudimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txudimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxdonemask</name><description>接收完成中断使能标志位当使能接收完成中断，并且接收过程完成时，将产生接收完成中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxdonemask</name><usage>read-write</usage><enumeratedValue><name>rxdonemask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxdonemask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxthimask</name><description>RXFIFO 阙值中断使能标志位当使能RXFIFO 阙值中断，并且 RXFIFO 中的数据个数等于或者多于阙值数时，产生生 RX 中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxthimask</name><usage>read-write</usage><enumeratedValue><name>rxthimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxthimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxovimask</name><description>RXFIFO 溢出中断使能位注意：当使能RXFIFO 流出中断，并且检测到TXOVIF 为 1 时，将产生溢出中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxovimask</name><usage>read-write</usage><enumeratedValue><name>rxovimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxovimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxudimask</name><description>RXFIFO 下溢中断使能位注意：当使能RXFIFO 下溢中断，并且检测到TXUDIF 为 1 时，将产生下溢中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxudimask</name><usage>read-write</usage><enumeratedValue><name>rxudimask_0</name><description>中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxudimask_1</name><description>中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>i2s_int_flag</name><addressOffset>0x8</addressOffset><description>中断标志位，可用于查询中断是否产生及清除相关中断</description><size>32</size><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>13</bitOffset><bitWidth>19</bitWidth><access>read-only</access></field><field><name>txif</name><description>I2S  发送中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>txif</name><usage>read</usage><enumeratedValue><name>txif_0</name><description>未发生I2S 中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txif_1</name><description>I2S 有发送中断产生</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxif</name><description>I2S  接收中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>rxif</name><usage>read</usage><enumeratedValue><name>rxif_0</name><description>未发生I2S 中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxif_1</name><description>I2S 有接收中断产生</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>i2sif</name><description>I2S  中断标志位注意：只要 RX 或者 TX 之一有中断，此位就会置位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>i2sif</name><usage>read</usage><enumeratedValue><name>i2sif_0</name><description>未发生I2S 中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>i2sif_1</name><description>I2S 有中断产生</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>lzcif</name><description>左声道零交叉检测标志此位指示左通道下一个样本数据符号位改变或所有数据位为零。注意：写 1 来清除中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>lzcif</name><usage>read-write</usage><enumeratedValue><name>lzcif_0</name><description>未检测到零交叉</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>lzcif_1</name><description>检测到零交叉</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rzcif</name><description>右声道零交叉检测标志此位指示右通道下一个样本数据符号位改变或所有数据位为零。注意：写 1 来清除中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rzcif</name><usage>read-write</usage><enumeratedValue><name>rzcif_0</name><description>未检测到零交叉</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rzcif_1</name><description>检测到零交叉</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txdoneif</name><description>发送完成中断标志注意：写 1 来清除中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txdoneif</name><usage>read-write</usage><enumeratedValue><name>txdoneif_0</name><description>本次发送未完成</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txdoneif_1</name><description>本次发送完成</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txthif</name><description>RXFIFO 中断标志注意：当 TXFIFO 中字的个数(TXCNT)等于或者少于TXTH 设置的阙值时，这个位会被置 1，直至向 TXFIFO 中的写入数据并且 TXCNT 的值大于 TXTH 的值后，它才会变回 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>txthif</name><usage>read</usage><enumeratedValue><name>txthif_0</name><description>TXFIFO 中的字个数大于阙值</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txthif_1</name><description>TXFIFO 中的字个数小于或等于于阙值.</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txovif</name><description>TXFIFO 溢出中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txovif</name><usage>read-write</usage><enumeratedValue><name>txovif_0</name><description>TXFIFO 没有发生溢出中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txovif_1</name><description>TXFIFO 发生了溢出中断注意写 1 来清除中断标志</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txudif</name><description>TXFIFO 下溢中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txudif</name><usage>read-write</usage><enumeratedValue><name>txudif_0</name><description>TXFIFO 没有发生下溢中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txudif_1</name><description>TXFIFO 发生了下溢中断注意写 1 来清除中断标志</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxdoneif</name><description>接收完成中断标志注意：写 1 来清除中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxdoneif</name><usage>read-write</usage><enumeratedValue><name>rxdoneif_0</name><description>本次接收未完成</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxdoneif_1</name><description>本次接收完成</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxthif</name><description>RXFIFO 中断标志注意：当 RXFIFO 中字的个数等于或者多于RXTH 设置的阙值时，这个位会被置 1，直至RXFIFO 中的数据被读出并且RXCNT 的值小于RXTH 的值后，它才会变回 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>rxthif</name><usage>read</usage><enumeratedValue><name>rxthif_0</name><description>RXFIFO 中的字个数小于阙值</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxthif_1</name><description>RXFIFO 中的字个数等于或大于阙值.</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxovif</name><description>RXFIFO 溢出中断标志注意：写 1 来清除溢出中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxovif</name><usage>read-write</usage><enumeratedValue><name>rxovif_0</name><description>RXFIFO 没有发生溢出中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxovif_1</name><description>RXFIFO 发生了溢出中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxudif</name><description>RXFIFO 下溢中断标志</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxudif</name><usage>read-write</usage><enumeratedValue><name>rxudif_0</name><description>RXFIFO 没有发生下溢中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxudif_1</name><description>RXFIFO 发生了下溢中断注意写 1 来清除下溢中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>i2s_status</name><addressOffset>0xc</addressOffset><description>用于查询 I2S 通信过程中 FIFO 的相关状态</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>10</bitOffset><bitWidth>22</bitWidth><access>read-only</access></field><field><name>validbyte</name><description>最后一个字中可用的字节数。</description><bitOffset>8</bitOffset><bitWidth>2</bitWidth><access>read-only</access><enumeratedValues><name>validbyte</name><usage>read</usage><enumeratedValue><name>validbyte_00</name><description>接收完成后，RXFIFO 中所有的字节都是可用的</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>validbyte_01</name><description>接收完成后，RXFIFO 中有 1 个字节是可用的</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>validbyte_10</name><description>接收完成后，RXFIFO 中有 2 个字节是可用的</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>validbyte_11</name><description>接收完成后，RXFIFO 中有 3 个字节是可用的</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>txcnt</name><description>记录当前时刻TXFIFO 中字的个数。…</description><bitOffset>4</bitOffset><bitWidth>4</bitWidth><access>read-only</access><enumeratedValues><name>txcnt</name><usage>read</usage><enumeratedValue><name>txcnt_0000</name><description>没有数据</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txcnt_0001</name><description>有 1 个字</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>txcnt_1000</name><description>有 8 个字</description><value>0x00000008</value></enumeratedValue></enumeratedValues></field><field><name>rxcnt</name><description>记录当前时刻RXFIFO 中字的个数。…</description><bitOffset>0</bitOffset><bitWidth>4</bitWidth><access>read-only</access><enumeratedValues><name>rxcnt</name><usage>read</usage><enumeratedValue><name>rxcnt_0000</name><description>没有数据</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxcnt_0001</name><description>有 1 个字</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>rxcnt_1000</name><description>有 8 个字</description><value>0x00000008</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>i2s_tx</name><addressOffset>0x10</addressOffset><description>控制器会将它里面的数据发送到总线上</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>txfifo</name><description>I2S 内置了8 个字长度的FIFO 用于存贮待发送的数据。每次向TXFIFO 中写一个字，TXFIFO 中的字就增加一个。I2S 控制器会自动将先进入TXFIFO 中的字发送出去。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>i2s_rx</name><addressOffset>0x14</addressOffset><description>控制器会将总线上的数据接收到它里面</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rxfifo</name><description>I2S 内置了 8 个字长度的 FIFO 用于存贮接收到的数据。每次从 RXFIFO 中读取一个字，RXFIFO 中的字就会少一个。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>pmu</name><version>0.1</version><description>Power Managent Unit</description><baseAddress>0x40000600</baseAddress><addressBlock><offset>0</offset><size>0x00000100</size><usage>Registers</usage></addressBlock><registers><register><name>ps_cr</name><addressOffset>0x0</addressOffset><description>用于配置32K 校准，配置32K 时钟源，设置芯片的STANDBY 功能</description><size>32</size><access>read-write</access><resetValue>0x00000002</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth><access>read-only</access></field><field><name>reserved</name><description>保留</description><bitOffset>4</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>bypass</name><description>32K 振荡电路BYPASS 信号，高有效。
当芯片进入STANBY 状态， 32K 时钟自动切换为振荡电路产生的 32K 时钟。芯片唤醒后，如需继续使用 40M 分频的 32K 时钟，需重新置位为 1。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>bypass</name><usage>read-write</usage><enumeratedValue><name>bypass_0</name><description>32K 由振荡电路产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>bypass_1</name><description>32K 由 40M 时钟分频得到</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rc_switch</name><description>RC 32K 振荡器校准电路启动开关；
要启动校准功能，需要此位先置 0，后置 1。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rc_switch</name><usage>read-write</usage><enumeratedValue><name>rc_switch_0</name><description>校准电路复位；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rc_switch_1</name><description>启动校准电路；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>standby_en</name><description>使能信号，高有效。
如果 WAKEUP 脚为无效电平，且没有配置TIMER0/1 中断唤醒，则该寄存器有效时，芯片进入STANDBY 状态；
如果唤醒中断产生，则芯片会从 STANDBY  状态切换到唤醒状态，唤醒条件满足，该位自动清 0。
唤醒源：WAKEUP 脚，TIMER0/TIMER1，RTC
1） WAKEUP 脚，高有效；要想芯片进入 STANDBY 状态，WAKEUP 脚必须处于低电平。要唤醒时，拉高 WAKEUP 脚，产生唤醒中断，使芯片离开STANDBY 状态。
2） TIMER0，定时器唤醒中断。
当 WAKEUP 脚为低，TIMER0 设置定时时间并使能，定时时间到会产生唤醒中断，使芯片离开STANDBY 状态。
3） RTC，定时时间到唤醒
当 WAKEUP  脚为低，RTC  定时时间到，会产生唤醒中断，使芯片离开
STANDBY 状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>standby_en</name><usage>read-write</usage><enumeratedValue><name>standby_en_0</name><description>芯片唤醒状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>standby_en_1</name><description>芯片进入STANDBY 状态</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>timer0</name><addressOffset>0x4</addressOffset><description>配置定时值（单位为秒），使能定时器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>17</bitOffset><bitWidth>15</bitWidth><access>read-only</access></field><field><name>timer0_en</name><description>使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>timer0_en</name><usage>read-write</usage><enumeratedValue><name>timer0_en_0</name><description>位使能。</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>timer0_en_1</name><description>使能；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>timer0_value</name><description>的定时值，单位:秒</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>int_src</name><addressOffset>0x14</addressOffset><description>提供PMU中断标志</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth><access>read-only</access></field><field><name>lasted_status</name><description>显示当次上电状态：</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>lasted_status</name><usage>read-write</usage><enumeratedValue><name>lasted_status_0</name><description>上电或复位启动</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>lasted_status_1</name><description>从休眠状态唤醒，写 1 清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access></field><field><name>rtc_int</name><description>RTC 定时中断标志位：</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rtc_int</name><usage>read-write</usage><enumeratedValue><name>rtc_int_0</name><description>有定时中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rtc_int_1</name><description>无定时中断产生，写 1 清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>wakeup_int</name><description>管脚唤醒中断标志位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>wakeup_int</name><usage>read-write</usage><enumeratedValue><name>wakeup_int_0</name><description>无 WAKEUP 唤醒中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>wakeup_int_1</name><description>有 WAEKUP 唤醒中断产生，写 1 清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>timer0_int</name><description>定时中断标志位：</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>timer0_int</name><usage>read-write</usage><enumeratedValue><name>timer0_int_0</name><description>无Timer0 中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>timer0_int_1</name><description>有Timer0 中断产生，写 1 清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register></registers></peripheral><peripheral><name>pwm</name><version>0.1</version><description>PWM</description><baseAddress>0x40011800</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>pwm_clkdiv01</name><addressOffset>0x0</addressOffset><description>对通道 0 和通道 1 的时钟进行分频</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>clkdiv1</name><description>CH1 分频计数器
由计数器值决定分频数
注意：分频范围为(0~65535)，如不需要分频，输入 0 或 1。</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>clkdiv0</name><description>CH0 分频计数器同CH1</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_clkdiv23</name><addressOffset>0x4</addressOffset><description>对通道 2 和通道 3 的时钟进行分频</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>clkdiv3</name><description>CH3 分频计数器同CH1</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>clkdiv2</name><description>CH2 分频计数器同CH1</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_ctl</name><addressOffset>0x8</addressOffset><description>用以配置或者控制一些可配置项</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>cnten</name><description>计数器计数使能
注意：每位分别控制每个通道，从高到低依次控制CH4、CH3、CH2、CH1 和CH0</description><bitOffset>27</bitOffset><bitWidth>5</bitWidth><access>read-write</access><enumeratedValues><name>cnten</name><usage>read-write</usage><enumeratedValue><name>cnten_0</name><description>停止计数</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cnten_1</name><description>开始计数</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>capinv</name><description>捕获反向使能标识位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>capinv</name><usage>read-write</usage><enumeratedValue><name>capinv_0</name><description>捕获模式输入信号反向无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>capinv_1</name><description>捕获模式输入信号反向有效，对输入信号取反</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cpen</name><description>捕获功能使能标识位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>cpen</name><usage>read-write</usage><enumeratedValue><name>cpen_0</name><description>CH0 捕获功能无效，RCAPDAT 和FCAPDAT 值不会被更新；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cpen_1</name><description>CH0 捕获功能有效，捕获并锁存 PWM 计数器，分别存储在 RCAPDAT（上升沿锁存）和FCAPDAT（下降沿锁存）</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cnttype3</name><description>CH3 计数器计数方式
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递减方式。</description><bitOffset>22</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>cnttype3</name><usage>read-write</usage><enumeratedValue><name>cnttype3_00</name><description>边缘对齐模式（计数器计数方式为递增，仅针对捕获模式）</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cnttype3_01</name><description>边缘对齐模式（计数器计数方式为递减，仅针对 PWM 模式）</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>cnttype3_10</name><description>中央对齐模式（仅针对 PWM 模式）</description><value>0x00000002</value></enumeratedValue></enumeratedValues></field><field><name>cnttype2</name><description>CH2 计数器计数方式同CH3</description><bitOffset>20</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>cnttype1</name><description>CH1 计数器计数方式同CH3</description><bitOffset>18</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>cnttype0</name><description>CH0 计数器计数方式同CH3</description><bitOffset>16</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>twosyncen</name><description>2 通道同步模式使能信号
PWM_CH0 和PWM_CH1 具有相同的相位，且相位由 PWM_CH0 决定；PWM_CH2和PWM_CH3 具有相同的相位，且相位由PWM_CH2 决定
15bit 控制CH3 和CH2
14bit 控制CH1 和CH0</description><bitOffset>14</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>twosyncen</name><usage>read-write</usage><enumeratedValue><name>twosyncen_0</name><description>不允许 2 通道同步</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>twosyncen_1</name><description>允许 2 通道同步，</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>poen</name><description>PWM 管脚输出使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>poen</name><usage>read-write</usage><enumeratedValue><name>poen_0</name><description>PWM 管脚置为输出状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>poen_1</name><description>PWM 管脚置为三态状态注意只是针对CH0</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cntmode</name><description>PWM 生成循环方式
注意：CNTMODE  变化过程中，PWM_CMPDAT  归零；每位分别控制每个通道，从高到低依次控制PW3、PW2、PW1 和PW0</description><bitOffset>8</bitOffset><bitWidth>4</bitWidth><access>read-write</access><enumeratedValues><name>cntmode</name><usage>read-write</usage><enumeratedValue><name>cntmode_0</name><description>单次模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cntmode_1</name><description>自动装载模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>allsyncen</name><description>全通道同步模式使能信号</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>allsyncen</name><usage>read-write</usage><enumeratedValue><name>allsyncen_0</name><description>不允许全部通道同步</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>allsyncen_1</name><description>允许全部通道同步，PWM_CH0、PWM_CH1、PWM_CH2 和 PWM_CH3 具有相同的相位，且相位由PWM_CH0 决定</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>pinv</name><description>PWM 输出信号极性使能
注意：每位分别控制每个通道，从高到低依次控制PW3、PW2、PW1 和PW0</description><bitOffset>2</bitOffset><bitWidth>4</bitWidth><access>read-write</access><enumeratedValues><name>pinv</name><usage>read-write</usage><enumeratedValue><name>pinv_0</name><description>PWM 输出极性翻转不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>pinv_1</name><description>PWM 输出极性翻转使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>outmode</name><description>输出模式
BIT0 控制CH0 和CH1</description><bitOffset>0</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>outmode</name><usage>read-write</usage><enumeratedValue><name>outmode_0</name><description>每两个通道非互补模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>outmode_1</name><description>每两个通道组成互补模式 BIT1 控制CH2 和CH3</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>pwm_period</name><addressOffset>0xc</addressOffset><description>用以设置通道 0 至通道 4 的周期</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>period3</name><description>CH3 周期寄存器值(注意：period 不可以大于 255) “沿对齐模式（计数器计数方式为递减）”：
寄存器值，周期值为（PERIOD + 1）
占空比=（CMP+1）/（PERIOD + 1）
CMP>=PERIOD：PWM 输出固定为高
CMP&lt;PERIOD：PWM 低电平宽度为（PERIOD-CMP），高电平宽度为（CMP+1）
CMP=0：PWM 低电平宽度为PERIOD，高电平宽度为 1；
“中间对齐模式”：
PERIOD 寄存器值：周期为 2*（PERIOD+1）
占空比=(2*CMP+1）/（2*（PERIOD+1））
CMP>PERIOD：PWM 持续为高
CMP&lt;=PERIOD：PWM 低电平=2*（PERIOD-CMP）+1，高电平=（2*CMP）+1
CMP=0：PWM 低电平宽度为 2*PERIOD+1，高电平宽度为 1。注意：“中间对齐模式”中，周期数不应为 255。
无论选择哪种对齐模式，通道周期均由分频数（N）和周期数（P）共同决定，即：输入时钟为 40MHz，经分频后时钟频率f_div 为：f_div = 40MHz/N，N 为分频数（16bit）。输出频率 f_output 为：f_output = f_div / P，P 为周期数。
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递
减方式。</description><bitOffset>24</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>period2</name><description>CH2 周期寄存器值(注意：period 不可以大于 255)
同PERIOD3</description><bitOffset>16</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>period1</name><description>CH1 周期寄存器值(注意：period 不可以大于 255)
同PERIOD3</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>period0</name><description>CH0 周期寄存器值(注意：period 不可以大于 255)
同PERIOD3</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_pnum</name><addressOffset>0x10</addressOffset><description>用以设置通道 0 至通道 4 的信号生
成周期数</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>pnum3</name><description>PWM3 生成周期数
设置 PWM3 周期数 PNUM3，当 PWM 产生PNUM3 个 PWM 信号后，停止生成信号，同时触发中断和置位中断状态字</description><bitOffset>24</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>pnum2</name><description>PWM2 生成周期数同PNUM3</description><bitOffset>16</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>pnum1</name><description>PWM1 生成周期数同PNUM3</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>pnum0</name><description>PWM0 生成周期数同PNUM3</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_cmpdat</name><addressOffset>0x14</addressOffset><description>用以存放通道 0 至通道 4 的比较值
以产生不同的占空比</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>cmp3</name><description>PWM3 比较寄存器值
“沿对齐模式（计数器计数方式为递减）”：
PERIOD 寄存器值，周期值为（PERIOD + 1）
占空比=（CMP+1）/（PERIOD + 1）
CMP>=PERIOD：PWM 输出固定位高
CMP&lt;PERIOD：PWM 低电平宽度为（PERIOD-CMP），高电平宽度为（CMP+1）
CMP=0：PWM 低电平宽度为PERIOD，高电平宽度为 1； “中间对齐模式”：
PERIOD 寄存器值：周期为 2*（PERIOD+1）
占空比=(2*CMP+1）/2*（PERIOD+1）
CMP>PERIOD：PWM 持续为高
CMP&lt;=PERIOD：PWM 低电平=2*（PERIOD-CMP）+1，高电平=（2*CMP）+1
CMP=0：PWM 低电平宽度为 2*PERIOD+1，高电平宽度为 1。
无论选择哪种对齐模式，通道周期均由分频数（N）和周期数（P）共同决定，即：输入时钟为 40MHz，经分频后时钟频率 f_div 为：f_div  =  40MHz/N，N 为分频数
（16bit）。输出频率 f_output 为：f_output = f_div / P，P 为周期数。
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递减方式。</description><bitOffset>24</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>cmp2</name><description>PWM2 比较寄存器值同CMP3</description><bitOffset>16</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>cmp1</name><description>PWM1 比较寄存器值同CMP3</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>cmp0</name><description>PWM0 比较寄存器值同CMP3</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_dtctl</name><addressOffset>0x18</addressOffset><description>用以配置或者控制死区相关的可配
置项</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>22</bitOffset><bitWidth>10</bitWidth></field><field><name>dten23</name><description>通道 2 和通道 3 是否可以插入死区有效标识
插入死区有效信号只有在通道的互补模式打开后，才有效。并且，如果插入有效信号为 0，则两个通道输出的互补信号没有死区的插入</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>dten23</name><usage>read-write</usage><enumeratedValue><name>dten23_0</name><description>插入死区无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dten23_1</name><description>插入死区有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>dten01</name><description>通道 0 和通道 1 是否可以插入死区有效标识同DTEN23</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>18</bitOffset><bitWidth>2</bitWidth></field><field><name>dtdiv</name><description>死区时钟分频控制</description><bitOffset>16</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>dtdiv</name><usage>read-write</usage><enumeratedValue><name>dtdiv_00</name><description>死区时钟等于基准时钟（40MHz）</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dtdiv_01</name><description>死区时钟等于基准时钟（40MHz）二分频</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>dtdiv_10</name><description>死区时钟等于基准时钟（40MHz）四分频</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>dtdiv_11</name><description>死区时钟等于基准时钟（40MHz）八分频</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>dtcnt23</name><description>通道 3 和通道 2 的死区间隔
8bit 决定死区间隔值，死区时钟由DTDIV 决定</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>dtcnt01</name><description>通道 1 和通道 0 的死区间隔
8bit 决定死区间隔值，死区时钟由DTDIV 决定</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_inten</name><addressOffset>0x1c</addressOffset><description>用以对相关中断进行使能控制</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>dma_request_en</name><description>DMA_request 使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>dma_request_en</name><usage>read-write</usage><enumeratedValue><name>dma_request_en_0</name><description>DMA_request 无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dma_request_en_1</name><description>DMA_request 有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>flien</name><description>下降沿缓存中断使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>flien</name><usage>read-write</usage><enumeratedValue><name>flien_0</name><description>下降沿缓存中断无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>flien_1</name><description>下降沿缓存中断有效注意针对CH0 而言</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rlien</name><description>上升沿缓存中断使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rlien</name><usage>read-write</usage><enumeratedValue><name>rlien_0</name><description>上升缓存中断无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rlien_1</name><description>上升沿缓存中断有效注意针对CH0 而言</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>pien</name><description>PWM 周期中断使能位
注意：当计数器计数到 0，且 PWM 周期个数满足PWM_PNUM 后，触发中断。</description><bitOffset>0</bitOffset><bitWidth>5</bitWidth><access>read-write</access><enumeratedValues><name>pien</name><usage>read-write</usage><enumeratedValue><name>pien_0</name><description>周期中断无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>pien_1</name><description>周期中断有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>pwm_intsts</name><addressOffset>0x20</addressOffset><description>用以查询相关中断的状态</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>10</bitOffset><bitWidth>22</bitWidth></field><field><name>overfl</name><description>计数器溢出标志
注意：当用户清除CFLIF 或CRLIF 时，本bit 也同时被清除</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>overfl</name><usage>read-write</usage><enumeratedValue><name>overfl_0</name><description>捕获模式，计数器计数过程中，计数器未溢出</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>overfl_1</name><description>捕获模式，计数器计数过程中，计数器溢出</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>flifov</name><description>下降沿延迟中断标识过跑状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>flifov</name><usage>read-write</usage><enumeratedValue><name>flifov_0</name><description>当CFILF 为 1 时，无下降沿延迟中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>flifov_1</name><description>当CFILF 为 1 时，又一次发生下降沿延迟中断注意当用户清除CFILF 时，本bit 也同时被清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rlifov</name><description>上升沿延迟中断标识过跑状态
注意：当用户清除CRILF 时，本bit 也同时被清除</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rlifov</name><usage>read-write</usage><enumeratedValue><name>rlifov_0</name><description>当CRILF 为 1 时，无上升沿延迟中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rlifov_1</name><description>当CRILF 为 1 时，又一次发生上升沿延迟中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cflif</name><description>捕获下降沿中断标识
注意：通过写入 1，清除该标识位；注意：针对CH0 而言</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>cflif</name><usage>read-write</usage><enumeratedValue><name>cflif_0</name><description>没有捕获到下降沿</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cflif_1</name><description>当捕获到下降沿，本位被设置为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>crlif</name><description>捕获上升沿中断标识
注意：通过写入 1，清除该标识位；注意：针对CH0 而言</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>crlif</name><usage>read-write</usage><enumeratedValue><name>crlif_0</name><description>没有捕获到上升沿</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>crlif_1</name><description>当捕获到上升沿，本位被设置为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>pif</name><description>PWM 周期中断标识
当PWM 产生指定周期PWM 信号后，该标识位置 1；通过软件写入 1，清除该标识注意：每位分别标识每个通道，从高到低依次控制 PW4、PW3、PW2、PW1 和PW0</description><bitOffset>0</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_capdat</name><addressOffset>0x24</addressOffset><description>用以捕获并计数来到通道 0  的上升
沿和下降沿</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>pwm_fcapdat</name><description>捕获下降沿寄存器
当输入信号存在下降沿时，存储当前计数器值</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field><field><name>pwm_rcapdat</name><description>捕获上升沿寄存器
当输入信号存在上升沿时，存储当前计数器值</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field></fields></register><register><name>pwm_brkctl</name><addressOffset>0x28</addressOffset><description>用以对制动模式进行控制</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>brkctl</name><description>制动模式使能
[7:3]分别对应CH4、CH3、CH2、CH1 和CH0</description><bitOffset>11</bitOffset><bitWidth>5</bitWidth><access>read-write</access><enumeratedValues><name>brkctl</name><usage>read-write</usage><enumeratedValue><name>brkctl_0</name><description>制动模式禁止</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>brkctl_1</name><description>制动模式启动</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>3</bitWidth></field><field><name>bkod</name><description>制动输出控制寄存器
[7:3]分别对应CH4、CH3、CH2、CH1 和CH0</description><bitOffset>3</bitOffset><bitWidth>5</bitWidth><access>read-write</access><enumeratedValues><name>bkod</name><usage>read-write</usage><enumeratedValue><name>bkod_0</name><description>当制动模式有效时，PWM 输出低电平</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>bkod_1</name><description>当制动模式有效时，PWM 输出高电平</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name></name><description>保留</description><bitOffset>0</bitOffset><bitWidth>3</bitWidth></field></fields></register><register><name>pwm_ch4_reg1</name><addressOffset>0x2c</addressOffset><description>对通道 4 的时钟进行分频</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>clkdiv4</name><description>CH4 分频计数器
由计数器值决定分频数
注意：分频范围为(0~65535)，如不需要分频，输入 0 或 1。</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>period4</name><description>CH4 周期寄存器值(注意：period 不可以大于 255) “沿对齐模式（计数器计数方式为递减）”：
PERIOD 寄存器值，周期值为（PERIOD + 1）
占空比=（CMP+1）/（PERIOD + 1）
CMP>=PERIOD：PWM 输出固定位高
CMP&lt;PERIOD：PWM 低电平宽度为（PERIOD-CMP），高电平宽度为（CMP+1）
CMP=0：PWM 低电平宽度为PERIOD，高电平宽度为 1； “中间对齐模式”：
PERIOD 寄存器值：周期为 2*（PERIOD+1）
占空比=(2*CMP+1）/（2*（PERIOD+1））
CMP>PERIOD：PWM 持续为高
CMP&lt;=PERIOD：PWM 低电平=2*（PERIOD-CMP）+1，高电平=（2*CMP）+1
CMP=0：PWM 低电平宽度为 2*PERIOD+1，高电平宽度为 1。注意：“中间对齐模式”中，周期数不应为 255。
无论选择哪种对齐模式，通道周期均由分频数（N）和周期数（P）共同决定，
即：输入时钟为 40MHz，经分频后时钟频率f_div 为：f_div = 40MHz/N，N 为分频数（16bit）。输出频率 f_output 为：f_output = f_div / P，P 为周期数。
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递
减方式。</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>ch4</name><description>生成周期数
设置PWM4 周期数为PNUM4，当PWM 产生PNUM4 个PWM 信号后，停止生成信号，同时触发中断和置位中断状态字</description><bitOffset>0</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field></fields></register><register><name>pwm_ch4_reg2</name><addressOffset>0x30</addressOffset><description>对通道 4 的相关配置项进行设置</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>cmp4</name><description>CH4 周期寄存器值
“沿对齐模式（计数器计数方式为递减）”：
PERIOD 寄存器值，周期值为（PERIOD + 1）
占空比=（CMP+1）/（PERIOD + 1）
CMP>=PERIOD：PWM 输出固定位高
CMP&lt;PERIOD：PWM 低电平宽度为（PERIOD-CMP），高电平宽度为（CMP+1）
CMP=0：PWM 低电平宽度为PERIOD，高电平宽度为 1； “中间对齐模式”：
PERIOD 寄存器值：周期为 2*（PERIOD+1）
占空比=(2*CMP+1）/2*（PERIOD+1）
CMP>PERIOD：PWM 持续为高
CMP&lt;=PERIOD：PWM 低电平=2*（PERIOD-CMP）+1，高电平=（2*CMP）+1
CMP=0：PWM 低电平宽度为 2*PERIOD+1，高电平宽度为 1。
无论选择哪种对齐模式，通道周期均由分频数（N）和周期数（P）共同决定，即：输入时钟为 40MHz，经分频后时钟频率 f_div 为：f_div  =  40MHz/N，N 为分频数
（16bit）。输出频率 f_output 为：f_output = f_div / P，P 为周期数。
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递减方式。</description><bitOffset>8</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>5</bitOffset><bitWidth>3</bitWidth></field><field><name>cnttype4</name><description>CH4 计数器计数方式
注意：在PWM 模式下，当计数器被设置为沿对齐模式时，需要设置计数方式为递减方式。</description><bitOffset>3</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>cnttype4</name><usage>read-write</usage><enumeratedValue><name>cnttype4_00</name><description>边缘对齐模式（计数器计数方式为递增，仅针对捕获模式）</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cnttype4_01</name><description>边缘对齐模式（计数器计数方式为递减，仅针对PWM 模式）</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>cnttype4_10</name><description>中央对齐模式（仅针对PWM 模式）</description><value>0x00000002</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>cntmode4</name><description>CH4 生成循环方式
注意：CNTMODE 变化过程中，PWM_CMPDAT 归零</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>cntmode4</name><usage>read-write</usage><enumeratedValue><name>cntmode4_0</name><description>单次模式</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cntmode4_1</name><description>自动装载模式</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>pinv4</name><description>CH4 输出信号极性使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>pinv4</name><usage>read-write</usage><enumeratedValue><name>pinv4_0</name><description>PWM 输出极性翻转不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>pinv4_1</name><description>PWM 输出极性翻转使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>pwm_cap2dat</name><addressOffset>0x34</addressOffset><description>用以捕获并计数来到通道 4  的上升
沿和下降沿</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>pwm_fcap2dat</name><description>捕获下降沿寄存器
当输入信号存在下降沿时，存储当前计数器值</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field><field><name>pwm_rcap2dat</name><description>捕获上升沿寄存器
当输入信号存在上升沿时，存储当前计数器值</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field></fields></register><register><name>pwm_cap2ctl</name><addressOffset>0x38</addressOffset><description>通道 4 的相关配置项进行设置</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>11</bitOffset><bitWidth>21</bitWidth></field><field><name>dma_request2_mask</name><description>注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>dma_request2_mask</name><usage>read-write</usage><enumeratedValue><name>dma_request2_mask_0</name><description>DMA_request2 无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>dma_request2_mask_1</name><description>DMA_request2 有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>flien2</name><description>下降沿缓存中断使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>flien2</name><usage>read-write</usage><enumeratedValue><name>flien2_0</name><description>下降沿缓存中断无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>flien2_1</name><description>下降沿缓存中断有效注意只是针对CH4</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rlien2</name><description>上升沿缓存中断使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rlien2</name><usage>read-write</usage><enumeratedValue><name>rlien2_0</name><description>上升缓存中断无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rlien2_1</name><description>上升沿缓存中断有效注意只是针对CH4</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>overfl2</name><description>计数器溢出标志
注意：当用户清除CFLIF 或CRLIF 时，本bit 也同时被清除注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>overfl2</name><usage>read-write</usage><enumeratedValue><name>overfl2_0</name><description>捕获模式，计数器计数过程中，计数器未溢出</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>overfl2_1</name><description>捕获模式，计数器计数过程中，计数器溢出</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>flifov2</name><description>下降沿延迟中断标识过跑状态
注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>flifov2</name><usage>read-write</usage><enumeratedValue><name>flifov2_0</name><description>当CFILF 为 1 时，无下降沿延迟中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>flifov2_1</name><description>当CFILF 为 1 时，又一次发生下降沿延迟中断注意当用户清除CFILF 时，本bit 也同时被清除</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rlifov2</name><description>上升沿延迟中断标识过跑状态
注意：当用户清除CRILF 时，本bit 也同时被清除注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rlifov2</name><usage>read-write</usage><enumeratedValue><name>rlifov2_0</name><description>当CRILF 为 1 时，无上升沿延迟中断产生</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rlifov2_1</name><description>当CRILF 为 1 时，又一次发生上升沿延迟中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cflif2</name><description>捕获下降沿中断标识
注意：通过写入 1，清除该标识位注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>cflif2</name><usage>read-write</usage><enumeratedValue><name>cflif2_0</name><description>没有捕获到下降沿</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cflif2_1</name><description>当捕获到下降沿，本位被设置为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>crlif2</name><description>捕获上升沿中断标识
注意：通过写入 1，清除该标识位注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>crlif2</name><usage>read-write</usage><enumeratedValue><name>crlif2_0</name><description>没有捕获到上升沿</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>crlif2_1</name><description>当捕获到上升沿，本位被设置为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>poen2</name><description>PWM 管脚输出使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>poen2</name><usage>read-write</usage><enumeratedValue><name>poen2_0</name><description>PWM 管脚置为输出状态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>poen2_1</name><description>PWM 管脚置为三态状态注意只是针对CH4</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>cpen2</name><description>捕获功能使能标识位
注意：只是针对CH4</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>cpen2</name><usage>read-write</usage><enumeratedValue><name>cpen2_0</name><description>CH4 捕获功能无效，RCAPDAT 和FCAPDAT 值不会被更新；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cpen2_1</name><description>CH4 捕获功能有效，捕获并锁存 PWM 计数器，分别存储在 RCAPDAT（上升沿锁存）和FCAPDAT（下降沿锁存）</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>capinv2</name><description>捕获反向使能标识位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>capinv2</name><usage>read-write</usage><enumeratedValue><name>capinv2_0</name><description>捕获模式输入信号反向无效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>capinv2_1</name><description>捕获模式输入信号反向有效，对输入信号取反注意只是针对CH4</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register></registers></peripheral><peripheral><name>rsa</name><version>0.1</version><description>RSA</description><baseAddress>0x40002200</baseAddress><addressBlock><offset>0</offset><size>0x00000700</size><usage>Registers</usage></addressBlock><registers><register><name>xbuf</name><addressOffset>0x0</addressOffset><description>数据X 寄存器</description><size>32</size><access>read-write</access></register><register><name>ybuf</name><addressOffset>0x100</addressOffset><description>数据Y 寄存器</description><size>32</size><access>read-write</access></register><register><name>mbuf</name><addressOffset>0x200</addressOffset><description>数据M 寄存器</description><size>32</size><access>read-write</access></register><register><name>dbuf</name><addressOffset>0x300</addressOffset><description>数据D 寄存器</description><size>32</size><access>read-write</access></register><register><name>rsacon</name><addressOffset>0x400</addressOffset><description>RSA  控制寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>6</bitOffset><bitWidth>26</bitWidth></field><field><name>mul_start</name><description>模乘启动控制位。软件写“1”启动模乘运算，运算结束后，硬件自动清“0”。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>soft_reset</name><description>提供软复位功能，高有效。软件写“1”进行软复位，复位完成后，硬件自动清“0”。
1.设置参数MC 和N  为 0。
2.启动模乘后（bit5 置 1），将此位置“1”，会终止当前的运算（当 bit0 变高，表示软复位命令执行完成，运算被终止），但内部数据缓冲区（X，Y，M，D）中已经完成的部分运算结果会保留。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>mul_mode</name><description>模乘模式选择。</description><bitOffset>2</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>mul_mode</name><usage>read-write</usage><enumeratedValue><name>mul_mode_00</name><description>X = D*D mod M</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>mul_mode_01</name><description>D = X*Y mod M</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>mul_mode_10</name><description>X = D*Y mod M</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>mul_mode_11</name><description>D = X*X mod M</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>mul_complete</name><description>模乘运算完成标识，高有效。硬件置“1”，软件清“0”。软件写“1”无效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>rsamc</name><addressOffset>0x404</addressOffset><description>参数MC 寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsamc</name><description>对应参数MC（32bit）。复位值全 0。读出值为全 0。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>rsan</name><addressOffset>0x408</addressOffset><description>参数N 寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>7</bitOffset><bitWidth>25</bitWidth></field><field><name>rsan</name><description>对应参数 N（7bit）。N 值为模乘长度除以 32 的值。</description><bitOffset>0</bitOffset><bitWidth>7</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>rst</name><version>0.1</version><description>Reset</description><baseAddress>0x40013c00</baseAddress><addressBlock><offset>0</offset><size>0x1ffec400</size><usage>Registers</usage></addressBlock><registers><register><name>sw_clkg_en</name><addressOffset>0x0</addressOffset><description>软件配置模块是否关断时钟</description><size>32</size><access>read-write</access><resetValue>0x00007fff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>15</bitOffset><bitWidth>17</bitWidth></field><field><name>soft_7816_gate_en</name><description>配置 7816/uart2 模块时钟的门控，默认 7816 模块门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_7816_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_7816_gate_en_0</name><description>7816 模块时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_7816_gate_en_1</name><description>7816 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_gpsec_gate_en</name><description>配置gpsec 模块时钟的门控，默认gpsec 模块门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_gpsec_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_gpsec_gate_en_0</name><description>gpsec 模块时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_gpsec_gate_en_1</name><description>gpsec 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rsa_gate_en</name><description>配置RSA 时钟的门控，默认RSA 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rsa_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_rsa_gate_en_0</name><description>RSA 模块时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rsa_gate_en_1</name><description>RSA 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_i2s_gate_en</name><description>配置i2s 时钟的门控，默认i2s 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_i2s_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_i2s_gate_en_0</name><description>i2s 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_i2s_gate_en_1</name><description>i2s 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_lcd_gate_en</name><description>配置lcd 时钟的门控，默认lcd 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_lcd_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_lcd_gate_en_0</name><description>lcd 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_lcd_gate_en_1</name><description>lcd 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_pwm_gate_en</name><description>配置pwm 时钟的门控，默认pwm 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_pwm_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_pwm_gate_en_0</name><description>pwm 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_pwm_gate_en_1</name><description>pwm 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_sd_adc_gate_en</name><description>配置sd_adc_时钟的门控，默认sd_adc_门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_sd_adc_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_sd_adc_gate_en_0</name><description>sd_adc_时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_sd_adc_gate_en_1</name><description>sd_adc_时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_gpio_gate_en</name><description>配置GPIO 时钟的门控，默认GPIO 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_gpio_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_gpio_gate_en_0</name><description>GPIO 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_gpio_gate_en_1</name><description>GPIO 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_timer_gate_en</name><description>配置timer 时钟的门控，默认timer 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_timer_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_timer_gate_en_0</name><description>timer 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_timer_gate_en_1</name><description>timer 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rf_cfg_gate_en</name><description>内部使用，请勿修改。配置rf_cfg 时钟的门控，默认rf_cfg 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rf_cfg_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_rf_cfg_gate_en_0</name><description>rf_cfg 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rf_cfg_gate_en_1</name><description>rf_cfg 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_dma_gate_en</name><description>表示供给dma 时钟域的时钟是否关断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_dma_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_dma_gate_en_0</name><description>dma 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_dma_gate_en_1</name><description>dma 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_ls_spi_gate_en</name><description>配置低速spi 时钟的门控，默认低速spi 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_ls_spi_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_ls_spi_gate_en_0</name><description>低速spi 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_ls_spi_gate_en_1</name><description>低速spi 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_uart1_gate_en</name><description>配置uart1 时钟的门控，默认uart1 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_uart1_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_uart1_gate_en_0</name><description>uart1 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_uart1_gate_en_1</name><description>uart1 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_uart0_gate_en</name><description>配置uart0 时钟的门控，默认uart0 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_uart0_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_uart0_gate_en_0</name><description>uart0 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_uart0_gate_en_1</name><description>uart0 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_i2c_gate_en</name><description>配置i2c 时钟的门控，默认i2c 门控开启</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_i2c_gate_en</name><usage>read-write</usage><enumeratedValue><name>soft_i2c_gate_en_0</name><description>i2c 时钟关闭</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_i2c_gate_en_1</name><description>i2c 时钟开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>sw_clk_mask</name><addressOffset>0x4</addressOffset><description>软件配置模块是否自适应关断时钟</description><size>32</size><access>read-write</access><resetValue>0x0000007e</resetValue><fields><field><name>soft_cpu_clk_gt_mask</name><description>表示供给 CPU 时钟域（包括 CPU，bus1、ROM、SRAM）的时钟是否能够自适应的关断（当 CPU 需要进入WFI 状态的时候，不要设置自适应关断）</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_cpu_clk_gt_mask</name><usage>read-write</usage><enumeratedValue><name>soft_cpu_clk_gt_mask_0</name><description>允许自适应关断和开启</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_cpu_clk_gt_mask_1</name><description>不允许自适应关断和开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留，内部使用，请勿修改</description><bitOffset>2</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>soft_sdioahb_clk_gt_mask</name><description>表示供给sdio ahb 时钟域的时钟是否能够自适应的关断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_sdioahb_clk_gt_mask</name><usage>read-write</usage><enumeratedValue><name>soft_sdioahb_clk_gt_mask_0</name><description>允许自适应关断和开启</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_sdioahb_clk_gt_mask_1</name><description>不允许自适应关断和开启</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_pmu_clk_gt_mask</name><description>pll 输出的时钟后有一个门控单元，采用该寄存器配置，表示是否允许被 PMU 关断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_pmu_clk_gt_mask</name><usage>read-write</usage><enumeratedValue><name>soft_pmu_clk_gt_mask_0</name><description>允许PMU 关断该门控单元，从而关断时钟</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_pmu_clk_gt_mask_1</name><description>不允许PMU 关断该门控单元</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>reserve</name><addressOffset>0x8</addressOffset><size>32</size></register><register><name>sw_rst_ctrl</name><addressOffset>0xc</addressOffset><description>软件配置复位模块</description><size>32</size><access>read-write</access><resetValue>0x01ffffff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>25</bitOffset><bitWidth>7</bitWidth></field><field><name>soft_rst_7816_n</name><description>软件复位 7816/uart2 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_7816_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_7816_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_7816_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_gpsec_n</name><description>软件复位gpsec 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_gpsec_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_gpsec_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_gpsec_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_rsa_n</name><description>软件复位RSA 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_rsa_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_rsa_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_rsa_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_i2s_n</name><description>软件复位i2s 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_i2s_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_i2s_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_i2s_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_lcd_n</name><description>软件复位lcd 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_lcd_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_lcd_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_lcd_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_pwm_n</name><description>软件复位pwm 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_pwm_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_pwm_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_pwm_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_io_ctrl_n</name><description>软件复位io_ctrl 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_io_ctrl_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_io_ctrl_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_io_ctrl_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_sar_adc_n</name><description>软件复位sar_adc 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_sar_adc_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_sar_adc_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_sar_adc_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_timer_n</name><description>软件复位timer 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_timer_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_timer_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_timer_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_gpio_n</name><description>软件复位gpio 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_gpio_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_gpio_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_gpio_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_rf_cfg_n</name><description>软件复位配置 RF 的寄存器模块(内部使用，请勿修改)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_rf_cfg_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_rf_cfg_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_rf_cfg_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_spis_n</name><description>软件复位高速spi 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_spis_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_spis_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_spis_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_spim_n</name><description>软件复位低速spi 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_spim_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_spim_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_spim_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_uart1_n</name><description>软件复位片内uart1 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_uart1_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_uart1_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_uart1_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_uart0_n</name><description>软件复位片内uart0 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_uart0_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_uart0_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_uart0_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_i2c_n</name><description>软件复位片内i2c 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_i2c_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_i2c_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_i2c_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_bus2_n</name><description>软件复位片内bus2 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_bus2_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_bus2_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_bus2_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_bus1_n</name><description>软件复位片内bus1 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_bus1_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_bus1_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_bus1_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_apb_n</name><description>软件复位abp 桥接模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_apb_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_apb_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_apb_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_mem_mng_n</name><description>软件复位mem_mng 模块(内部使用，请勿修改)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_mem_mng_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_mem_mng_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_mem_mng_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_dma_n</name><description>软件复位dma 模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_dma_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_dma_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_dma_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_sdio_ahb_n</name><description>软件复位sdio ahb 时钟域模块</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_sdio_ahb_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_sdio_ahb_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_sdio_ahb_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_sec_n</name><description>软件复位安全模块(内部使用，请勿修改)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_sec_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_sec_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_sec_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_mac_n</name><description>软件复位mac 模块(内部使用，请勿修改)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_mac_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_mac_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_mac_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>soft_rst_bbp_n</name><description>软件复位bbp 模块(内部使用，请勿修改)</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>soft_rst_bbp_n</name><usage>read-write</usage><enumeratedValue><name>soft_rst_bbp_n_0</name><description>复位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>soft_rst_bbp_n_1</name><description>复位释放</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>sys_clk_div</name><addressOffset>0x10</addressOffset><description>配置时钟分频比</description><size>32</size><access>read-write</access><resetValue>0x00002212</resetValue><fields><field><name>divide_freq_en</name><description>当需要重新配置cpu_clk_divider  ，wlan_clk_divider  ，bus2_syncdn_factor，sdadc_fdiv时，置位本寄存器，硬件自动更新上述四个参数到分频器，然后清零本寄存器。 
注：此处配置分频因子时，当Divide_freq_en 有效时，所有因子必须已经有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>divide_freq_en</name><usage>read-write</usage><enumeratedValue><name>divide_freq_en_0</name><description>分频系数已生效</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>divide_freq_en_1</name><description>要求硬件更新分频参数</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>29</bitOffset><bitWidth>2</bitWidth></field><field><name>rsa_clk_sel</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rsa_clk_sel</name><usage>read-write</usage><enumeratedValue><name>rsa_clk_sel_0</name><description>: 40MHz</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rsa_clk_sel_1</name><description>: 80MHz</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>sdadc_fdiv</name><description>clk_sar_adc  分频因子：
以 40M 为时钟源进行分频。分频系数即为所配分频值。</description><bitOffset>12</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>bus2_syncdn_factor</name><description>bus1 和bus2 的时钟比例关系，应该为N：1
其中N 为整数，在实际调整时，主要看CPU 的工作频率和bus2 的时钟频率之比。由于默认cpu 采用 80MHz 时钟，bus2 采用 40MHz 时钟，则 N=2</description><bitOffset>8</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>wlan_clk_divider</name><description>从PLL 出来的时钟分频后，送给wlan 系统。本寄存器为分频因子，该因子>=1。默认分频因子为 1，即不对 pll 的 160MHz 输出分频，得到 160MHz 时钟，作为根节点时钟送给wlan（wlan 在继续分频得到更为详细的低频时钟）；
注：二级总线及APB 时钟为wlan 根节点时钟四分频</description><bitOffset>4</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>cpu_clk_divider</name><description>从PLL 出来的时钟分频后，送给CPU。本寄存器为分频因子，该因子>=2。
默认分频因子为 2，即复位释放后，对 PLL 输出的 160MHz 时钟 2 分频，送给 cpu
的是 80MHz 时钟。当需要调整cpu 所需时钟时，可以重新配置本参数</description><bitOffset>0</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field></fields></register><register><name>debug_ctrl</name><addressOffset>0x14</addressOffset><description>配置ADC/DAC 回环测试</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>jtag</name><description>使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>jtag</name><usage>read-write</usage><enumeratedValue><name>jtag_0</name><description>:  禁止JTAG 调试功能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>jtag_1</name><description>:  使能JTAG 调试功能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留，请勿修改</description><bitOffset>0</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field></fields></register><register><name>i2s_clk_ctrl</name><addressOffset>0x18</addressOffset><description>配置I2S 时钟</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>18</bitOffset><bitWidth>14</bitWidth></field><field><name>bclkdiv</name><description>BCLK 分配器：F_BCLK = F_I2SCLK / BCLKDIV
注意：如果未选择EXTAL_EN 而使用内部PLL 则F_I2SCLK  =F_CPU  (与CPU 频率相同)。
假设F_CPU = 160MHz，启用WXTAL_EN 时F_I2SCLK =  外部晶振频率，
BCLKDIV = round (F_I2SCLK/(Fs*W*F)) 其中 Fs 是音频数据的采样频率，W 是字宽；数据为单声道时F = 1；
当数据为立体声时F = 2。
例如，如果使用内部 PLL 且数据宽度为 24 位，则格式为立体声格式，采样频率为
128KHz，BCLKDIV 应配置为（160 * 10e6 / 128 * 10e3 * 24 * 2）= 10'h1a。</description><bitOffset>8</bitOffset><bitWidth>10</bitWidth><access>read-write</access></field><field><name>mclkdiv</name><description>如果选择外部时钟，则该MCLK 分频器用于产生适当的MCLK 频率。
F_mclk = F_I2SCLK / (2 * MCLKDIV)；
当MCLKDIV = 0 时F_I2SCLK 是外部时钟；当MCLKDIV >= 1 时F_mclk = F_I2SCLK；
注意：F_mclk 应配置为 256 * fs，其中 fs 是采样频率。</description><bitOffset>2</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field><field><name>mclken</name><description>MCLK 使能开关</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>mclken</name><usage>read-write</usage><enumeratedValue><name>mclken_0</name><description>禁止MCLK</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>mclken_1</name><description>使能MCLK</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>extal_en</name><description>外部时钟选择，选择使用内部I2S 块时钟还是外部时钟
注意：使用外部时钟时，外部时钟必须为 2 * N * 256 fs，其中 fs 为采样频率，N 必须为整数。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>extal_en</name><usage>read-write</usage><enumeratedValue><name>extal_en_0</name><description>内部时钟</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>extal_en_1</name><description>外部时钟</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register></registers></peripheral><peripheral><name>rtc</name><version>0.1</version><description>real time</description><baseAddress>0x40000600</baseAddress><addressBlock><offset>0</offset><size>0x00000100</size><usage>Registers</usage></addressBlock><registers><register><name>rtc_r1</name><addressOffset>0xc</addressOffset><description>配置RTC 日时分秒值，配置使能定时</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rtc_int_en</name><description>定时中断功能使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rtc_int_en</name><usage>read-write</usage><enumeratedValue><name>rtc_int_en_0</name><description>不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rtc_int_en_1</name><description>使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>29</bitOffset><bitWidth>2</bitWidth></field><field><name>date</name><description>日初值/日定时值</description><bitOffset>24</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>21</bitOffset><bitWidth>3</bitWidth></field><field><name>hour</name><description>小时初值/小时定时值</description><bitOffset>16</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>14</bitOffset><bitWidth>2</bitWidth></field><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>6</bitWidth></field><field><name>reserved</name><description>保留</description><bitOffset>6</bitOffset><bitWidth>2</bitWidth></field><field><name>second</name><description>秒初值/秒定时值</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field></fields></register><register><name>rtc_r2</name><addressOffset>0x10</addressOffset><description>配置RTC 年月值，配置使能计时</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>17</bitOffset><bitWidth>15</bitWidth></field><field><name>rtc_en</name><description>计时功能使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rtc_en</name><usage>read-write</usage><enumeratedValue><name>rtc_en_0</name><description>不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rtc_en_1</name><description>使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>reserved</name><description>保留</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>year</name><description>年初值/年定时值</description><bitOffset>8</bitOffset><bitWidth>7</bitWidth><access>read-write</access></field><field><name>reserved</name><description>保留</description><bitOffset>4</bitOffset><bitWidth>4</bitWidth></field><field><name>month</name><description>月初值/月定时值</description><bitOffset>0</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>spi</name><version>0.1</version><description>SPI</description><baseAddress>0x40000200</baseAddress><addressBlock><offset>0</offset><size>0x00000100</size><usage>Registers</usage></addressBlock><registers><register><name>ch_cfg</name><addressOffset>0x0</addressOffset><description>用以对收发通道的相关项进行一些配置</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>rx_invalid_bit</name><description>表示接收通路在开始接收时，前多少 bit 是无效数据，这些无效数据需要直接扔掉，不进入Rx FIFO。只有后续的数据进入Rx FIFO本寄存器与Tx/Rx length 配合使用。最后实际存入 Rx FIFO 的数据量为Tx/Rx length- RX_INVALID_BIT注：master 模式有效Motorola/ TI 模式有效</description><bitOffset>23</bitOffset><bitWidth>8</bitWidth><access>read-write</access></field><field><name>clear</name><description>FIFOs，清除 Tx 和Rx FIFO 的内容,同时同步复位master 和slave 所有电路（配置寄存器除外）软件置 1，硬件清 0注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>clear</name><usage>read-write</usage><enumeratedValue><name>clear_0</name><description>不清除FIFO</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>clear_1</name><description>清除有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>continue</name><description>mode，该模式下，spi 发送不受Tx FIFO 空的影响。，持续传输，直至整个传输过程完成。Rx FIFO 满后，SCK 停止翻转，等待RX FIFO 有空间接收数据满，则需要暂停传输，直至rx fifo 可以存数为止注：master 有效一般情况下，不设置该模式。开启该模式时，如果tx fifo 中没有数据，有可能导致无效数据先发送出去。所以请先填入数据后，再启动spi masterMotorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>continue</name><usage>read-write</usage><enumeratedValue><name>continue_0</name><description>normal,Tx  FIFO 空后，需要等待FIFO 中出现数据，SCK 停止翻转，同理，</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>continue_1</name><description>continue mode，Tx fifo 空，仍可以传输，直至传输完成，但此时如果rx fifo</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxchon</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxchon</name><usage>read-write</usage><enumeratedValue><name>rxchon_0</name><description>: Rx channel off</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxchon_1</name><description>: Rx channel on</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txchon</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txchon</name><usage>read-write</usage><enumeratedValue><name>txchon_0</name><description>: Tx channel off</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txchon_1</name><description>: Tx channel on</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tx</name><description>/Rx lengthSpi 在传输时，有效的SCK 数也间接的反映了发送或者接收数据的长度。当（TxChOn=1，RxChOn=1）时，表示发送的 bit 数，以及最大接收的bit 数（具体接收多少与RX_INVALID_BIT 有关）当（TxChOn=1，RxChOn=0）时，表示发送的bit 数，当（TxChOn=0，RxChOn=1）时，表示最大接收的 bit  数（具体接收多少与 RX_INVALID_BIT  有关，实际接收数为Tx/Rx length - RX_INVALID_BIT）当（TxChOn=0，RxChOn=0）时，无意义。注：master 有效Motorola/TI/microwire 模式有效</description><bitOffset>3</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>chip</name><description>selects注：master 有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>chip</name><usage>read-write</usage><enumeratedValue><name>chip_0</name><description>SPI_CS 有效信号为 0</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>chip_1</name><description>SPI_CS 有效信号为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>force</name><description>CS out该信号配合Chip selects 可以实现输出csn 信号可编程，即该信号为 1 时，spi_cs  =Chip selects注：master 有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>force</name><usage>read-write</usage><enumeratedValue><name>force_0</name><description>spi_cs 信号输出由硬件控制</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>force_1</name><description>spi_cs 信号输出由软件控制，具体输出值为Chip selects</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>spi</name><description>start,命令 SPI 开始接收或者发送，写 1 为spi 开始工作，之后，自动归零Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi</name><usage>read-write</usage><enumeratedValue><name>spi_0</name><description>停止spi 工作</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_1</name><description>启动spi 的一次发送或者接收，自动归零注master 有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>spi_cfg</name><addressOffset>0x4</addressOffset><description>对 SPI 通信相关项进行配置</description><size>32</size><access>read-write</access><resetValue>0x00000004</resetValue><fields><field><name>rsv</name><description></description><bitOffset>19</bitOffset><bitWidth>13</bitWidth></field><field><name>fram</name><description>FORMAT选择master 支持那个厂家的协议注：master 有效</description><bitOffset>17</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>fram</name><usage>read-write</usage><enumeratedValue><name>fram_00</name><description>:motorola 2’b01:TI</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>fram_10</name><description>:microwire 2’b11:RSV</description><value>0x00000002</value></enumeratedValue></enumeratedValues></field><field><name>spi_tx</name><description>pin always drivenMotorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi_tx</name><usage>read-write</usage><enumeratedValue><name>spi_tx_0</name><description>spi 输出只有在spi_cs 有效时，被驱动，其它时间为三态</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_tx_1</name><description>spi 输出一直有驱动，即使没有数据传输注master/slave 都有效</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rsv</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>cs</name><description>hold， spi_cs 在数据传输完成后持续有效的时间，即spi_cs 的hold 时间注： master 有效Motorola 模式有效</description><bitOffset>12</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>cs</name><usage>read-write</usage><enumeratedValue><name>cs_000</name><description>>=1      个APB  总线 CLK</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cs_001</name><description>>=2      个APB  总线CLK</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>cs_010</name><description>>=4      个APB  总线 CLK</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>cs_011</name><description>>=8      个APB  总线 CLK</description><value>0x00000003</value></enumeratedValue><enumeratedValue><name>cs_100</name><description>>=16    个APB  总线 CLK</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>cs_101</name><description>>=32    个APB  总线 CLK</description><value>0x00000005</value></enumeratedValue><enumeratedValue><name>cs_110</name><description>>=64    个APB  总线 CLK</description><value>0x00000006</value></enumeratedValue><enumeratedValue><name>cs_111</name><description>>=127    个APB  总线 CLK</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>cs</name><description>setup， spi_cs 在数据传输前提前有效的时间，即spi_cs 的setup 时间Motorola 模式有效注：master 有效</description><bitOffset>9</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>cs</name><usage>read-write</usage><enumeratedValue><name>cs_000</name><description>>=1    个APB  总线 CLK</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>cs_001</name><description>>=2    个APB  总线 CLK</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>cs_010</name><description>>=4    个APB  总线 CLK</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>cs_011</name><description>>=8    个APB  总线 CLK</description><value>0x00000003</value></enumeratedValue><enumeratedValue><name>cs_100</name><description>>=16    个APB  总线 CLK</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>cs_101</name><description>>=32    个APB  总线 CLK</description><value>0x00000005</value></enumeratedValue><enumeratedValue><name>cs_110</name><description>>=64    个APB  总线 CLK</description><value>0x00000006</value></enumeratedValue><enumeratedValue><name>cs_111</name><description>>=127  个APB  总线 CLK</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>spi</name><description>-out delay, SPI 数据输出相对与SCK 的delay，主要是为了hold time 考虑。[8:7]      系统时钟周期数(APB clock)注：master/slave 都有效Motorola 模式有效</description><bitOffset>7</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>spi</name><usage>read-write</usage><enumeratedValue><name>spi_00</name><description>0</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_01</name><description>1</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>spi_10</name><description>2</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>spi_11</name><description>3</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>frame</name><description>delay，默认在一帧（spi_cs 有效期间）传输结束到下一帧开始的间隔为SCK时钟周期的一半，即SPI_CS 无效时间。但为了兼容性，此处可配置。默认至少0.5SCK [6:4]    SCK clock例如，按照 block 模式传输 128byte 的数据，数据传输完成后，会加入所设置的延迟时间。注：master 有效</description><bitOffset>4</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>frame</name><usage>read-write</usage><enumeratedValue><name>frame_000</name><description>0</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>frame_001</name><description>2</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>frame_010</name><description>4</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>frame_011</name><description>8</description><value>0x00000003</value></enumeratedValue><enumeratedValue><name>frame_100</name><description>16</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>frame_101</name><description>32</description><value>0x00000005</value></enumeratedValue><enumeratedValue><name>frame_110</name><description>64</description><value>0x00000006</value></enumeratedValue><enumeratedValue><name>frame_111</name><description>127</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>bigendian</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>bigendian</name><usage>read-write</usage><enumeratedValue><name>bigendian_0</name><description>数据格式采用小端模式，即传输过程中，先发低字节</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>bigendian_1</name><description>数据格式采用大端模式，即传输过程中，先发高字节</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>master</name><description>/SLAVE注：master/slave 都有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>master</name><usage>read-write</usage><enumeratedValue><name>master_0</name><description>slave，该设备是slave 1’b1master，该设备是master</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>spi</name><description>CPHA注：master/slave 都有效Motorola 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi</name><usage>read-write</usage><enumeratedValue><name>spi_0</name><description>传输模式A</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_1</name><description>传输模式B</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>spi</name><description>CPOL，SCK 在 IDLE 时的极性注：master/slave 都有效Motorola 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi</name><usage>read-write</usage><enumeratedValue><name>spi_0</name><description>SCK IDLE 时为 0</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_1</name><description>SCK IDLE  时为 1</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>clk_cfg</name><addressOffset>0x8</addressOffset><description>用以设置时钟分频系数</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>divider</name><description>FSCK  = FAPB_CLK/ ( 2 x (Divider +1))注：master 有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field><field><name>rsv</name><description></description><bitOffset>16</bitOffset><bitWidth>16</bitWidth></field><field><name>divider</name><description>FSCK  = FAPB_CLK/ ( 2 x (Divider +1))注：master 有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>mode_cfg</name><addressOffset>0xc</addressOffset><description>配置传输模式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>rxtrigger</name><description>levelRX FIFO  存储的数据触发中断或者DMA 请求的阈值：0~7word只有rxbuffer 中的数据大于RxTrigger level，才会触发中断或者请求DMA 搬移注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>6</bitOffset><bitWidth>3</bitWidth><access>read-write</access></field><field><name>rsv</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth></field><field><name>txtrigger</name><description>levelTX FIFO  存储的数据触发中断或者DMA 请求的阈值：0~7word只有txbuffer 中的数据大于等于TxTrigger level，才会触发中断或者请求 DMA 搬移注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>2</bitOffset><bitWidth>3</bitWidth><access>read-write</access></field><field><name>rxdma</name><description>On，采用DMA 搬移数据使能注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxdma</name><usage>read-write</usage><enumeratedValue><name>rxdma_0</name><description>不采用DMA，</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxdma_1</name><description>采用DMA</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>txdma</name><description>On，采用DMA 搬移数据使能注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txdma</name><usage>read-write</usage><enumeratedValue><name>txdma_0</name><description>不采用DMA，</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txdma_1</name><description>采用DMA</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>spi_int_mask</name><addressOffset>0x10</addressOffset><description>屏蔽或者使能相关中断</description><size>32</size><access>read-write</access><resetValue>0x000000ff</resetValue><fields><field><name>rsv</name><description></description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>inten_spi_timeout</name><description>Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>inten_spi_timeout</name><usage>read-write</usage><enumeratedValue><name>inten_spi_timeout_0</name><description>允许产生spi_timeout  中断 1’b1 不允许产生spi_timeout  中断注master/slave 都有效</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>inten_spi_done</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>inten_spi_done</name><usage>read-write</usage><enumeratedValue><name>inten_spi_done_0</name><description>spi 发送或者接收完成，允许产生中断</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>inten_spi_done_1</name><description>spi 发送或者接收完成，不允许产生中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intenrxoverrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intenrxoverrun</name><usage>read-write</usage><enumeratedValue><name>intenrxoverrun_0</name><description>Rx FIFO overflow  中断使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intenrxoverrun_1</name><description>Rx FIFO overflow  中断不使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intenrxunderrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intenrxunderrun</name><usage>read-write</usage><enumeratedValue><name>intenrxunderrun_0</name><description>Rx FIFO underflow  中断不使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intenrxunderrun_1</name><description>Rx FIFO underflow  中断使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intentxoverrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intentxoverrun</name><usage>read-write</usage><enumeratedValue><name>intentxoverrun_0</name><description>Tx FIFO    overflow  中断使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intentxoverrun_1</name><description>Tx FIFO    overflow  中断不使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intentxunderrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intentxunderrun</name><usage>read-write</usage><enumeratedValue><name>intentxunderrun_0</name><description>Tx FIFO    underflow  中断使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intentxunderrun_1</name><description>Tx FIFO    underflow  中断不使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intenrxfifordy</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intenrxfifordy</name><usage>read-write</usage><enumeratedValue><name>intenrxfifordy_0</name><description>Rx FIFO  有数据上传中断使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intenrxfifordy_1</name><description>Rx FIFO  有数据上传中断不使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>intentxfifordy</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>intentxfifordy</name><usage>read-write</usage><enumeratedValue><name>intentxfifordy_0</name><description>Tx FIFO 可以向TX FIFO 写数据中断使能</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>intentxfifordy_1</name><description>Tx FIFO  可以向TX FIFO 写数据中断不使能</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>spi_int_source</name><addressOffset>0x14</addressOffset><description>用于查询中断源</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>spi_timeout</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi_timeout</name><usage>read-write</usage><enumeratedValue><name>spi_timeout_0</name><description>rxfifo 中没有结尾数据需要CPU 取走</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_timeout_1</name><description>rxfifo 中有结尾数据需要CPU 取走写 1 清零</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>spi_done</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi_done</name><usage>read-write</usage><enumeratedValue><name>spi_done_0</name><description>SPI 发送或者接收没有完成</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_done_1</name><description>SPI 发送或者接收完成写 1 清零</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rxoverrun</name><description>写 1 清零注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxoverrun</name><usage>read-write</usage><enumeratedValue><name>rxoverrun_0</name><description>Rx FIFO overflow 1’b1Rx FIFO overflow</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>rxunderrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxunderrun</name><usage>read-write</usage><enumeratedValue><name>rxunderrun_0</name><description>Rx FIFO underflow 1’b1Rx FIFO underflow写 1 清零</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>txoverrun</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txoverrun</name><usage>read-write</usage><enumeratedValue><name>txoverrun_0</name><description>Tx FIFO    overflow 1’b1Tx FIFO    overflow写 1 清零</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>txunderrun</name><description>在 continue mode = 1  的情况下，永远不会产生该中断。注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txunderrun</name><usage>read-write</usage><enumeratedValue><name>txunderrun_0</name><description>Tx FIFO    underflow 1’b1Tx FIFO    underflow写 1 清零</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>rxfifordy</name><description>写 1 清零注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>rxfifordy</name><usage>read-write</usage><enumeratedValue><name>rxfifordy_0</name><description>Rx FIFO  数据量&lt;= RxTrigger level，不需要上传 1’b1Rx FIFO 数据量> RxTrigger level，要求上传</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>txfifordy</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>txfifordy</name><usage>read-write</usage><enumeratedValue><name>txfifordy_0</name><description>Tx FIFO  数据量 > TxTrigger level，不可以向TX FIFO 写数据 1’b1Tx FIFO  数据量 &lt;= TxTrigger level，可以向TX FIFO 写数据写 1 清零</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>spi_status</name><addressOffset>0x18</addressOffset><description>列举 SPI 通信中的相关状态</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>13</bitOffset><bitWidth>19</bitWidth></field><field><name>spi</name><description>Busy注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access><enumeratedValues><name>spi</name><usage>read</usage><enumeratedValue><name>spi_0</name><description>SPI 没有发送和接收任务</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_1</name><description>SPI 处于发送或者接收过程</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>rx</name><description>FIFO fill levelRx FIFO 中数据量，单位为字节注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>6</bitOffset><bitWidth>6</bitWidth><access>read-only</access></field><field><name>tx</name><description>FIFO fill levelTx FIFO 中数据量，单位为字节注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-only</access></field></fields></register><register><name>spi_time_out</name><addressOffset>0x1c</addressOffset><description>设置 SPI 通信超时</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>spi_timer_en</name><description>注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>spi_timer_en</name><usage>read-write</usage><enumeratedValue><name>spi_timer_en_0</name><description>不允许timer 计时</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>spi_timer_en_1</name><description>:允许timer  计时</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>spi_time_out</name><description>当一次传输完成后，在接收通路 rxfifo  中，结尾的数据如果不能触发接收中断RxFifoRdy 或者DMA 请求时，需要采用计时机制来通知CPU 搬走结尾数据。具体方法：当 rxfifo 处于idle 状态下（没有读写操作，没有 dma 请求，cs 无效，rxfifo中有数据，且数据量小于等于 RxTrigger level），开始计数，达到本寄存器设置的值，则触发timeout 中断，请求CPU 搬走结尾数据。任何对rxfifo 的读写操作都会清楚timeout 计时器。所表示的时间为： T = SPI_TIME_OUT/FAPB_CLK注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>31</bitWidth><access>read-write</access></field></fields></register><register><name>spi_tx_data</name><addressOffset>0x20</addressOffset><description>TX FIFO，用于存放待发送数据</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>spi_tx_data</name><description>向Tx FIFO 写数据的窗口地址注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>trans_mode</name><addressOffset>0x24</addressOffset><description>设置传输模式</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rsv</name><description></description><bitOffset>30</bitOffset><bitWidth>2</bitWidth></field><field><name>ti_blk_len</name><description>在TI 的时序模式下，每个 block 传输的长度，即每次 CS 有效之后的传输数据长度。支持 4~32bit……..TI 模式有效</description><bitOffset>24</bitOffset><bitWidth>6</bitWidth><access>read-write</access><enumeratedValues><name>ti_blk_len</name><usage>read-write</usage><enumeratedValue><name>ti_blk_len_4</name><description>:    4bit 长数据 6’h5:    5bit 长数据 6’h6:    6bit 长数据</description><value>0x00000004</value></enumeratedValue><enumeratedValue><name>ti_blk_len_20</name><description>:    32bit 长数据注master 有效</description><value>0x00000020</value></enumeratedValue></enumeratedValues></field><field><name>micro_burst</name><description>1b’1：Microwire 模式下，采用burst 传输，即 Tx 发送控制字，Rx 接收数据，依次交替进行，MICRO_CONTROL_LEN 表示的是控制字长度，MICRO_DAT_LEN  表示的是发送或者接收字的长度，Tx/Rx  length  表示的是整个传输过程中有效 sck， burst    模 式 下 ， 发 送 接 收 交 替 进 行 的 次 数 为 （ Tx/Rx    length  ）/(MICRO_CONTROL_LEN+ MICRO_DAT_LEN+1)length-MICRO_CONTROL_LEN-1，其中m 表示接收多少个（MICRO_DAT_LEN）长度的字注：master 有效microwire 模式有效1）tx_ch_on = 1, rx_ch_on = 0,此时，只有发送，MICRO_CONTROL_LEN 表示的是控制字长度，Tx/Rx length 表示的是整个传输过程中有效sck，此时发送的数据长度为m*MICRO_DAT_LEN = Tx/Rx length - MICRO_CONTROL_LEN，其中 m 表示发送多少个（MICRO_DAT_LEN）长度的字2 ） tx_ch_on   =   1,   rx_ch_on   =   1 ， 此时， Tx  发送控制字， Rx   接收数据，MICRO_CONTROL_LEN 表示的是控制字长度，Tx/Rx length 表示的是整个传输过程 中 有 效  sck  ， 接 收 数 据 长 度 为  m*MICRO_DAT_LEN    =    Tx/Rx</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>micro_burst</name><usage>read-write</usage><enumeratedValue><name>micro_burst_0</name><description>Microwire 模式下，不采用burst 传输在此模式下，有两种情况</description><value>0x00000000</value></enumeratedValue></enumeratedValues></field><field><name>micro_dat_len</name><description>Microwire 模式下，在burst 模式模式时，每个burst 传输数据的长度从 1~32：……..</description><bitOffset>8</bitOffset><bitWidth>6</bitWidth><access>read-write</access><enumeratedValues><name>micro_dat_len</name><usage>read-write</usage><enumeratedValue><name>micro_dat_len_1</name><description>:    1bit 长数据 6’h2:    2bit 长数据 6’h3:    3bit 长数据</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>micro_dat_len_20</name><description>32bit 长数据注master 有效 microwire 模式有效</description><value>0x00000020</value></enumeratedValue></enumeratedValues></field><field><name>micro_control_len</name><description>Microwire 模式下，命令字的长度从 1~32：……..microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-write</access><enumeratedValues><name>micro_control_len</name><usage>read-write</usage><enumeratedValue><name>micro_control_len_1</name><description>:    1bit 长命令 6’h2:    2bit 长命令 6’h3:    3bit 长命令</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>micro_control_len_20</name><description>32bit 长命令注master 有效</description><value>0x00000020</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>slv_xmit_len</name><addressOffset>0x28</addressOffset><description>作为从设备时用于存放发送出去或者接收到的数据的长度</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>slv_tx_length</name><description>作为slave 时，在 cs 有效期间，发送出去的数据长度，单位为bit注：slave 有效Motorola 模式有效</description><bitOffset>16</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field><field><name>slv_rx_length</name><description>作为slave 时，在 cs 有效期间，接收到的数据长度，单位为bit注：slave 有效Motorola 模式有效</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-only</access></field></fields></register><register><name>spi_rx_data</name><addressOffset>0x30</addressOffset><description>RX FIFO，用于存放接收到的数据</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>rx_address</name><description>从Rx FIFO 读数据的窗口地址注：master/slave 都有效Motorola/TI/microwire 模式有效</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>timer</name><version>0.1</version><description>Timer</description><baseAddress>0x40010e00</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>tmr_config</name><addressOffset>0x0</addressOffset><description>标准us 定时分频值，由总线时钟分频得到标准us 定时，该值等于 APB  总线频率（MHz）减一</description><size>32</size><access>read-write</access><resetValue>0x00000027</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>7</bitOffset><bitWidth>25</bitWidth></field><field><name>prescale</name><description>时钟分频配置prescale。例如：
apb_clk=40MHz
prescale = 40 – 1 = 8’d39</description><bitOffset>0</bitOffset><bitWidth>7</bitWidth><access>read-write</access></field></fields></register><register><name>tmr_csr</name><addressOffset>0x4</addressOffset><description>定时器控制寄存器</description><size>32</size><access>read-write</access><resetValue>0x06318c63</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>30</bitOffset><bitWidth>2</bitWidth><access>read-write</access></field><field><name>tmr6_csr</name><description>，同TMR1_CSR</description><bitOffset>25</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>tmr5_csr</name><description>，同TMR1_CSR</description><bitOffset>20</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>tmr4_csr</name><description>，同TMR1_CSR</description><bitOffset>15</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>tmr3_csr</name><description>，同TMR1_CSR</description><bitOffset>10</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>tmr2_csr</name><description>，同TMR1_CSR</description><bitOffset>5</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>tmr_int_status</name><description>中断状态寄存器，写 1 清除</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tmr_int_status</name><usage>read-write</usage><enumeratedValue><name>tmr_int_status_0</name><description>Timer 无中断产生；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tmr_int_status_1</name><description>Timer 产生中断；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tmr_int_en</name><description>中断使能寄存器</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tmr_int_en</name><usage>read-write</usage><enumeratedValue><name>tmr_int_en_0</name><description>定时时间完成后不产生中断；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tmr_int_en_1</name><description>定时时间完成后产生中断；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tmr_en</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tmr_en</name><usage>read-write</usage><enumeratedValue><name>tmr_en_0</name><description>定时器不工作；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tmr_en_1</name><description>使能定时器</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tmr_mode</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tmr_mode</name><usage>read-write</usage><enumeratedValue><name>tmr_mode_0</name><description>定时器重复定时；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tmr_mode_1</name><description>定时器只定时一次，定时完成后自动关闭；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>tmr_unit</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>tmr_unit</name><usage>read-write</usage><enumeratedValue><name>tmr_unit_0</name><description>定时单位为 us；</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>tmr_unit_1</name><description>定时单位为 ms；</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>tmr1_prd</name><addressOffset>0x8</addressOffset><description>Timer1 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr1_value</name><description>配置定时器 1 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>tmr2_prd</name><addressOffset>0xc</addressOffset><description>Timer2 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr2_value</name><description>配置定时器 2 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>tmr3_prd</name><addressOffset>0x10</addressOffset><description>Timer3 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr3_value</name><description>配置定时器 3 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>tmr4_prd</name><addressOffset>0x14</addressOffset><description>Timer4 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr4_value</name><description>配置定时器 4 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>tmr5_prd</name><addressOffset>0x18</addressOffset><description>Timer5 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr5_value</name><description>配置定时器 5 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>tmr6_prd</name><addressOffset>0x1c</addressOffset><description>Timer6 定时值配置寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tmr6_value</name><description>配置定时器 6 的定时值</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register></registers></peripheral><peripheral><name>uart0</name><version>0.1</version><description>uart0</description><baseAddress>0x40010800</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>uart_line_ctrl</name><addressOffset>0x0</addressOffset><description>uart 通信的数据格式设置</description><size>32</size><access>read-write</access><resetValue>0x0000000b</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>uart_rx_enable</name><description>接收使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>uart_tx_enable</name><description>发送使能，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>send_break_enable</name><description>发送break 数据包。Uart 会在该为被置位后发送完一个break 数据包，发送完成后自动清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity</name><description>极性</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>parity</name><usage>read-write</usage><enumeratedValue><name>parity_0</name><description>偶校验</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>parity_1</name><description>奇校验</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>parity</name><description>en
奇偶检验使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>stop_bit_count</name><description>个数</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>stop_bit_count</name><usage>read-write</usage><enumeratedValue><name>stop_bit_count_0</name><description>1 个停止位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>stop_bit_count_1</name><description>2 个停止位</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>uart_bit_length</name><description>比特长度。</description><bitOffset>0</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>uart_bit_length</name><usage>read-write</usage><enumeratedValue><name>uart_bit_length_0</name><description>5bit</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>uart_bit_length_1</name><description>6bit</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>uart_bit_length_2</name><description>7bit</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>uart_bit_length_3</name><description>8bit</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>auto_flow_ctrl</name><addressOffset>0x4</addressOffset><description>uart rts/cts 硬件流控设置</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>5</bitOffset><bitWidth>27</bitWidth></field><field><name>rts_trigger_level</name><description>在afc_enable 有效时，决定何时需要将RTS 置无效。</description><bitOffset>2</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>rts_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rts_trigger_level_0</name><description>rxfifo 有 4 个以上字节 3’h1rxfifo 有 8 个以上字节 3’h2rxfifo 有 12 个以上字节 3’h3rxfifo 有 16 个以上字节 3’h4rxfifo 有 20 个以上字节 3’h5rxfifo 有 24 个以上字节 3’h6rxfifo 有 28 个以上字节</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rts_trigger_level_7</name><description>rxfifo 有 31 个以上字节</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>rts_set</name><description>当AFC_enable 无效时，软件可以通过设置此位来完成接收流量控制。当 AFC_enable
有效时，此位不关心。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>afc_enable</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>afc_enable</name><usage>read-write</usage><enumeratedValue><name>afc_enable_1</name><description>有效，接收条件rts 使用rts_trigger_level 控制产生。</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>dma_ctrl</name><addressOffset>0x8</addressOffset><description>uart dma 传输模式设置</description><size>32</size><access>read-write</access><resetValue>0x00000024</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>rxfifo_timeout_num</name><description>rxfifo 中存在数据小于rxfifo_trigger_level 情况下，如果 N 个包的时间内，没有接收到新的数据时，产生rxfifo timeout 中断。
该计时功能使能后，无论是第一次计时还是上一次计时完成，都只在接收到至少 1
个包后才开始计时</description><bitOffset>3</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>rxfifo_timeout_en</name><description>rxfifo 超时使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rx_dma_enable</name><description>接收DMA 使能，高有效。
0：表示接收过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_dma_enable</name><description>发送DMA 使能，高有效。
0：表示发送过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>uart_fifo_ctrl</name><addressOffset>0xc</addressOffset><description>设置 uart fifo 触发等级</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>6</bitOffset><bitWidth>26</bitWidth></field><field><name>rxfifo_trigger_level</name><description></description><bitOffset>4</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>rxfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rxfifo_trigger_level_0</name><description>1byte</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_1</name><description>4byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_2</name><description>8byte 2’h316byte</description><value>0x00000002</value></enumeratedValue></enumeratedValues></field><field><name>txfifo_trigger_level</name><description></description><bitOffset>2</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>txfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>txfifo_trigger_level_0</name><description>empty</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_1</name><description>4byte 2’h28byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_3</name><description>16byte</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>rxfifo_reset</name><description>复位rxfifo，将rxfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_reset</name><description>复位txfifo，将txfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>baud_rate_ctrl</name><addressOffset>0x10</addressOffset><description>设置uart  通信波特率</description><size>32</size><access>read-write</access><resetValue>0x00030081</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>20</bitOffset><bitWidth>12</bitWidth></field><field><name>ubdiv_frac</name><description>系统时钟除以 16 倍波特率时钟商的小数部分指示。具体值为frac×16 。
（参考章节 2.3.2，波特率计算方法）</description><bitOffset>16</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>ubdiv</name><description>系统时钟除以 16 倍波特率时钟商的整数部分减 1。默认系统时钟为 40MHz，波特率为 19200。
（参考章节 2.3.2，波特率计算方法）</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>int_mask</name><addressOffset>0x14</addressOffset><description>设置uart 需要使用的中断</description><size>32</size><access>read-write</access><resetValue>0x000001ff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>overrun_error_int_mask</name><description>， rxfifo 溢出中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error_int_mask</name><description>，奇偶检验中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error_int_mask</name><description>，数据帧出错中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect_int_mask</name><description>，break 信号检测中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed_indicate_mask</name><description>，CTS 信号变化中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout_int_mask</name><description>，rxfifo 接收数据超时中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_int_mask</name><description>，rxfifo 达到触发值中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_int_mask</name><description>，txfifo 达到触发值中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_empty_int_mask</name><description>，txfifo 为空中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>int_src</name><addressOffset>0x18</addressOffset><description>uart 中断状态指示</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>overrun_error_rxfifo</name><description>出现溢出。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error</name><description>接收到的包校验位错误。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error</name><description>接收到的包停止位错误。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect</name><description>接收到break 包。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed</name><description>cts 信号变化则产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout</name><description>rxfifo 中数据长度小于rxfifo trigger level 但N 个数据周期没有接收到任何数据，则产生中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_interrupt</name><description>当rxfifo 中数据个数由小于rxfifo trigger level 中指定的数变成大于或等于该数时，产生此中断。
此时应该根据rxfifo count 确定当前数据帧大小。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_interrupt</name><description>当txfifo 中数据个数由大于txfifo trigger level 中指定的数变成小于或等于该数时，产生中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_fifo_empty_interrupt</name><description>当发送完成当前包，并且txfifo 为空时，产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>fifo_status</name><addressOffset>0x1c</addressOffset><description>fifo 状态，cts 状态查询</description><size>32</size><access>read-write</access><resetValue>0x00001000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>13</bitOffset><bitWidth>19</bitWidth></field><field><name>cts_status</name><description>当前cts 的状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_count</name><description>rxfifo 中数据个数</description><bitOffset>6</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field><field><name>txfifo_count</name><description>txfifo 中数据个数</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field></fields></register><register><name>tx_data_window</name><addressOffset>0x20</addressOffset><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tx_data_window</name><description>发送数据起始地址。
注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>rx_data_window</name><addressOffset>0x30</addressOffset><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rx_data_window</name><description>接收数据起始地址。
注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>uart1</name><version>0.1</version><description>uart1</description><baseAddress>0x40010a00</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>uart_line_ctrl</name><addressOffset>0x0</addressOffset><description>uart 通信的数据格式设置</description><size>32</size><access>read-write</access><resetValue>0x0000000b</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>uart_rx_enable</name><description>接收使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>uart_tx_enable</name><description>发送使能，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>send_break_enable</name><description>发送break 数据包。Uart 会在该为被置位后发送完一个break 数据包，发送完成后自动清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity</name><description>极性</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>parity</name><usage>read-write</usage><enumeratedValue><name>parity_0</name><description>偶校验</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>parity_1</name><description>奇校验</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>parity</name><description>en
奇偶检验使能，高有效</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>stop_bit_count</name><description>个数</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>stop_bit_count</name><usage>read-write</usage><enumeratedValue><name>stop_bit_count_0</name><description>1 个停止位</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>stop_bit_count_1</name><description>2 个停止位</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>uart_bit_length</name><description>比特长度。</description><bitOffset>0</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>uart_bit_length</name><usage>read-write</usage><enumeratedValue><name>uart_bit_length_0</name><description>5bit</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>uart_bit_length_1</name><description>6bit</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>uart_bit_length_2</name><description>7bit</description><value>0x00000002</value></enumeratedValue><enumeratedValue><name>uart_bit_length_3</name><description>8bit</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>auto_flow_ctrl</name><addressOffset>0x4</addressOffset><description>uart rts/cts 硬件流控设置</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>5</bitOffset><bitWidth>27</bitWidth></field><field><name>rts_trigger_level</name><description>在afc_enable 有效时，决定何时需要将RTS 置无效。</description><bitOffset>2</bitOffset><bitWidth>3</bitWidth><access>read-write</access><enumeratedValues><name>rts_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rts_trigger_level_0</name><description>rxfifo 有 4 个以上字节 3’h1rxfifo 有 8 个以上字节 3’h2rxfifo 有 12 个以上字节 3’h3rxfifo 有 16 个以上字节 3’h4rxfifo 有 20 个以上字节 3’h5rxfifo 有 24 个以上字节 3’h6rxfifo 有 28 个以上字节</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rts_trigger_level_7</name><description>rxfifo 有 31 个以上字节</description><value>0x00000007</value></enumeratedValue></enumeratedValues></field><field><name>rts_set</name><description>当AFC_enable 无效时，软件可以通过设置此位来完成接收流量控制。当 AFC_enable
有效时，此位不关心。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>afc_enable</name><description></description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>afc_enable</name><usage>read-write</usage><enumeratedValue><name>afc_enable_1</name><description>有效，接收条件rts 使用rts_trigger_level 控制产生。</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>dma_ctrl</name><addressOffset>0x8</addressOffset><description>uart dma 传输模式设置</description><size>32</size><access>read-write</access><resetValue>0x00000024</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>8</bitOffset><bitWidth>24</bitWidth></field><field><name>rxfifo_timeout_num</name><description>rxfifo 中存在数据小于rxfifo_trigger_level 情况下，如果 N 个包的时间内，没有接收到新的数据时，产生rxfifo timeout 中断。
该计时功能使能后，无论是第一次计时还是上一次计时完成，都只在接收到至少 1
个包后才开始计时</description><bitOffset>3</bitOffset><bitWidth>5</bitWidth><access>read-write</access></field><field><name>rxfifo_timeout_en</name><description>rxfifo 超时使能</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rx_dma_enable</name><description>接收DMA 使能，高有效。
0：表示接收过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_dma_enable</name><description>发送DMA 使能，高有效。
0：表示发送过程使用中断。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>uart_fifo_ctrl</name><addressOffset>0xc</addressOffset><description>设置 uart fifo 触发等级</description><size>32</size><access>read-write</access><resetValue>0x00000014</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>6</bitOffset><bitWidth>26</bitWidth></field><field><name>rxfifo_trigger_level</name><description></description><bitOffset>4</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>rxfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>rxfifo_trigger_level_0</name><description>1byte</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_1</name><description>4byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>rxfifo_trigger_level_2</name><description>8byte 2’h316byte</description><value>0x00000002</value></enumeratedValue></enumeratedValues></field><field><name>txfifo_trigger_level</name><description></description><bitOffset>2</bitOffset><bitWidth>2</bitWidth><access>read-write</access><enumeratedValues><name>txfifo_trigger_level</name><usage>read-write</usage><enumeratedValue><name>txfifo_trigger_level_0</name><description>empty</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_1</name><description>4byte 2’h28byte</description><value>0x00000001</value></enumeratedValue><enumeratedValue><name>txfifo_trigger_level_3</name><description>16byte</description><value>0x00000003</value></enumeratedValue></enumeratedValues></field><field><name>rxfifo_reset</name><description>复位rxfifo，将rxfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_reset</name><description>复位txfifo，将txfifo 状态清空</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>baud_rate_ctrl</name><addressOffset>0x10</addressOffset><description>设置uart  通信波特率</description><size>32</size><access>read-write</access><resetValue>0x00030081</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>20</bitOffset><bitWidth>12</bitWidth></field><field><name>ubdiv_frac</name><description>系统时钟除以 16 倍波特率时钟商的小数部分指示。具体值为frac×16 。
（参考章节 2.3.2，波特率计算方法）</description><bitOffset>16</bitOffset><bitWidth>4</bitWidth><access>read-write</access></field><field><name>ubdiv</name><description>系统时钟除以 16 倍波特率时钟商的整数部分减 1。默认系统时钟为 40MHz，波特率为 19200。
（参考章节 2.3.2，波特率计算方法）</description><bitOffset>0</bitOffset><bitWidth>16</bitWidth><access>read-write</access></field></fields></register><register><name>int_mask</name><addressOffset>0x14</addressOffset><description>设置uart 需要使用的中断</description><size>32</size><access>read-write</access><resetValue>0x000001ff</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>overrun_error_int_mask</name><description>， rxfifo 溢出中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error_int_mask</name><description>，奇偶检验中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error_int_mask</name><description>，数据帧出错中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect_int_mask</name><description>，break 信号检测中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed_indicate_mask</name><description>，CTS 信号变化中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout_int_mask</name><description>，rxfifo 接收数据超时中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_int_mask</name><description>，rxfifo 达到触发值中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_int_mask</name><description>，txfifo 达到触发值中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_empty_int_mask</name><description>，txfifo 为空中断屏蔽位，高有效。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>int_src</name><addressOffset>0x18</addressOffset><description>uart 中断状态指示</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>9</bitOffset><bitWidth>23</bitWidth></field><field><name>overrun_error_rxfifo</name><description>出现溢出。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>parity_error</name><description>接收到的包校验位错误。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>frame_error</name><description>接收到的包停止位错误。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>break_detect</name><description>接收到break 包。
DMA 情况下，此中断仍会产生。但DMA 操作不关心此中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>cts_changed</name><description>cts 信号变化则产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_data_timeout</name><description>rxfifo 中数据长度小于rxfifo trigger level 但N 个数据周期没有接收到任何数据，则产生中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_trigger_level_interrupt</name><description>当rxfifo 中数据个数由小于rxfifo trigger level 中指定的数变成大于或等于该数时，产生此中断。
此时应该根据rxfifo count 确定当前数据帧大小。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>txfifo_trigger_level_interrupt</name><description>当txfifo 中数据个数由大于txfifo trigger level 中指定的数变成小于或等于该数时，产生中断。
软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>tx_fifo_empty_interrupt</name><description>当发送完成当前包，并且txfifo 为空时，产生此中断。软件主动写 1 清 0。</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>fifo_status</name><addressOffset>0x1c</addressOffset><description>fifo 状态，cts 状态查询</description><size>32</size><access>read-write</access><resetValue>0x00001000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>13</bitOffset><bitWidth>19</bitWidth></field><field><name>cts_status</name><description>当前cts 的状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field><field><name>rxfifo_count</name><description>rxfifo 中数据个数</description><bitOffset>6</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field><field><name>txfifo_count</name><description>txfifo 中数据个数</description><bitOffset>0</bitOffset><bitWidth>6</bitWidth><access>read-write</access></field></fields></register><register><name>tx_data_window</name><addressOffset>0x20</addressOffset><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>tx_data_window</name><description>发送数据起始地址。
注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>rx_data_window</name><addressOffset>0x30</addressOffset><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>rx_data_window</name><description>接收数据起始地址。
注意：uart 发送与接收数据只支持字节操作，当采用 burst 传输时，有可能使用字节地址递增的方式，设计中最多支持 16-burst 的操作，即 16byte。因此从发送/接收起始地址后共 16byte（4 个字）都保留为发送/接收数据窗口。</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register></registers></peripheral><peripheral><name>watchdog</name><version>0.1</version><description>Watch Dog</description><baseAddress>0x40011000</baseAddress><addressBlock><offset>0</offset><size>0x00000200</size><usage>Registers</usage></addressBlock><registers><register><name>wd_ld</name><addressOffset>0x0</addressOffset><description>配置定时值，用于重复加载</description><size>32</size><access>read-write</access><resetValue>0xffffffff</resetValue><fields><field><name>conf_en</name><description>配置定时值，用于重复加载
此寄存器的值以APB 时钟为计数单位。
例如：以APB 时钟为 40MHZ，则定时值最大时长约 107s 左右，即
0FFFFFFFF/40000000</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-write</access></field></fields></register><register><name>wd_val</name><addressOffset>0x4</addressOffset><description>获取当前定时器的值</description><size>32</size><access>read-only</access><resetValue>0xffffffff</resetValue><fields><field><name>timer_value</name><description>获取当前定时器的值
要计算剩余时间，只要读取当前值即可。
要计算已经过去的时间，只要把寄存器WD_LD 的值减去寄存器WD_VAL 的值即可</description><bitOffset>0</bitOffset><bitWidth>32</bitWidth><access>read-only</access></field></fields></register><register><name>wd_ctrl</name><addressOffset>0x8</addressOffset><description>控制寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>2</bitOffset><bitWidth>30</bitWidth></field><field><name>reset_en</name><description>复位使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>reset_en</name><usage>read-write</usage><enumeratedValue><name>reset_en_0</name><description>WDG 复位条件产生时，不产生复位信号</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>reset_en_1</name><description>WDG 复位条件产生时，产生复位信号</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field><field><name>timer_en</name><description>定时使能位</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access><enumeratedValues><name>timer_en</name><usage>read-write</usage><enumeratedValue><name>timer_en_0</name><description>定时器不工作</description><value>0x00000000</value></enumeratedValue><enumeratedValue><name>timer_en_1</name><description>定时器工作，产生周期性中断</description><value>0x00000001</value></enumeratedValue></enumeratedValues></field></fields></register><register><name>wd_clr</name><addressOffset>0xc</addressOffset><description>中断清除寄存器</description><size>32</size><access>read-write</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>1</bitOffset><bitWidth>31</bitWidth></field><field><name>int_status_clr</name><description>中断状态清除位，写任意值清除当前中断状态</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-write</access></field></fields></register><register><name>wd_src</name><addressOffset>0x10</addressOffset><description>中断源寄存器</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>1</bitOffset><bitWidth>31</bitWidth></field><field><name>int_src</name><description>中断源寄存器，定时器功能打开，会同时产生该中断</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access></field></fields></register><register><name>wd_state</name><addressOffset>0x14</addressOffset><description>中断输出状态寄存器</description><size>32</size><access>read-only</access><resetValue>0x00000000</resetValue><fields><field><name>reserved</name><description>保留</description><bitOffset>1</bitOffset><bitWidth>31</bitWidth></field><field><name>int_output_status</name><description>中断输出状态寄存器。该中断在定时器关闭后不产生，但WD_SRC 可能为 1</description><bitOffset>0</bitOffset><bitWidth>1</bitWidth><access>read-only</access></field></fields></register></registers></peripheral></peripherals></device>